–ü–∏—à–∏ –ø–æ–ª–Ω–æ—Ü–µ–Ω–Ω—ã–π –∫–æ–¥ –±–µ–∑ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–≤ –≤ –Ω–µ–º —Å–∞–º–æ–º.
- –ø–ª–æ—Ö–æ —Ä–∞–±–æ—Ç–∞—é—Ç —Å–æ—Å—Ç–æ—è–Ω–∏—è, –∞ –∏–º–µ–Ω–Ω–æ: –ö–∞–∫ –±—É–¥—Ç–æ –±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞, –∫–∞–∫ —è —ç—Ç–æ –ø–æ–Ω—è–ª - —á–µ—Ä–µ–∑ /setmygroup, –ø–æ—Å–ª–µ —É–∫–∞–∑–∞–Ω–∏—è –≥—Ä—É–ø–ø—ã –º–µ–Ω—è –ø–µ—Ä–µ–±—Ä–æ—Å–∏–ª–æ –Ω–∞ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ, —Ö–æ—Ç—è —è –≤–æ–æ–±—â–µ –±—ã–ª –≤ –¥–æ–º–∞—à–∫–µ

‚ö†Ô∏è –û—à–∏–±–∫–∞ –≤ –±–æ—Ç–µ
–í—Ä–µ–º—è (UTC): 2025-11-26T18:40:20.834116
–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: 1843578375 @mihort
–î–µ–π—Å—Ç–≤–∏–µ: hw_apr:cac05d99-990b-465f-846b-762c80f6b30b

–û—à–∏–±–∫–∞: object NoneType can't be used in 'await' expression

Traceback:
Traceback (most recent call last):
  File "/RECODE/RECODE/app/handlers/start.py", line 161, in call
    return await self._process(handler, event, data, from_user)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/RECODE/RECODE/app/handlers/start.py", line 137, in _process
    return await handler(event, data)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/RECODE/RECODE/.venv/lib/python3.12/site-packages/aiogram/dispatcher/event/handler.py", line 43, in call
    return await wrapped()
           ^^^^^^^^^^^^^^^
  File "/RECODE/RECODE/app/handlers/admin.py", line 660, in admin_approve_hw
    await ctx.homework_service.add_public_homework(item["group_code"], item["subject"], item["text"], item["telegraph_url"])
TypeError: object NoneType can't be used in 'await' expression

–ë–∞–∑–∞ –ø—Ä–æ–µ–∫—Ç–∞: /storage/emulated/0/recode
–°—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–æ: 2025-11-27 11:03:59
–†–µ–∂–∏–º: –ü–û–õ–ù–´–ô

=== –°–≤–æ–¥–∫–∞ –ø–æ –ø–∞–ø–∫–∞–º ===
. ‚Äî —Ñ–∞–π–ª–æ–≤: 1, —Ä–∞–∑–º–µ—Ä: 617B, –ø–æ—Å–ª–µ–¥–Ω—è—è –ø—Ä–∞–≤–∫–∞: 2025-11-22 00:03:07
app ‚Äî —Ñ–∞–π–ª–æ–≤: 1, —Ä–∞–∑–º–µ—Ä: 13B, –ø–æ—Å–ª–µ–¥–Ω—è—è –ø—Ä–∞–≤–∫–∞: 2025-11-22 00:03:17
app/core ‚Äî —Ñ–∞–π–ª–æ–≤: 7, —Ä–∞–∑–º–µ—Ä: 12.6KB, –ø–æ—Å–ª–µ–¥–Ω—è—è –ø—Ä–∞–≤–∫–∞: 2025-11-25 19:38:07
app/handlers ‚Äî —Ñ–∞–π–ª–æ–≤: 6, —Ä–∞–∑–º–µ—Ä: 143.3KB, –ø–æ—Å–ª–µ–¥–Ω—è—è –ø—Ä–∞–≤–∫–∞: 2025-11-26 22:50:47
app/keyboards ‚Äî —Ñ–∞–π–ª–æ–≤: 4, —Ä–∞–∑–º–µ—Ä: 15.5KB, –ø–æ—Å–ª–µ–¥–Ω—è—è –ø—Ä–∞–≤–∫–∞: 2025-11-25 19:42:11
app/services ‚Äî —Ñ–∞–π–ª–æ–≤: 6, —Ä–∞–∑–º–µ—Ä: 72.3KB, –ø–æ—Å–ª–µ–¥–Ω—è—è –ø—Ä–∞–≤–∫–∞: 2025-11-26 22:58:38
config/homeworks ‚Äî —Ñ–∞–π–ª–æ–≤: 1, —Ä–∞–∑–º–µ—Ä: 1.9KB, –ø–æ—Å–ª–µ–¥–Ω—è—è –ø—Ä–∞–≤–∫–∞: 2025-11-26 23:03:25

=== –î—É–±–ª–∏–∫–∞—Ç—ã –ø–æ –∏–º–µ–Ω–∏ —Ñ–∞–π–ª–∞ (–≤ —Ä–∞–∑–Ω—ã—Ö –ø–∞–ø–∫–∞—Ö) ===
__init__.py:
    app/__init__.py
    app/handlers/__init__.py
admin.py:
    app/handlers/admin.py
    app/keyboards/admin.py
homework.py:
    app/handlers/homework.py
    app/keyboards/homework.py

=== –ü–æ–¥–æ–∑—Ä–∏—Ç–µ–ª—å–Ω—ã–µ .py (–Ω–µ –∏–º–ø–æ—Ä—Ç–∏—Ä—É—é—Ç—Å—è –¥—Ä—É–≥–∏–º–∏) ===
–ù–µ—Ç.

=== –°—Ç—Ä—É–∫—Ç—É—Ä–∞ ===
main.py  [Entry point]  (617B, 2025-11-22 00:03:07)
    __init__.py  [Package init]  (13B, 2025-11-22 00:03:17)
        bot.py  [Core]  (1.8KB, 2025-11-25 19:38:07)
        commands.py  [Core]  (886B, 2025-11-23 14:14:55)
        config.py  [Core]  (3.1KB, 2025-11-23 14:02:50)
        constants.py  [Core]  (104B, 2025-11-22 00:03:08)
        context.py  [Core]  (669B, 2025-11-23 14:05:07)
        fsm_storage.py  [Core]  (4.6KB, 2025-11-22 00:03:11)
        states.py  [Core]  (1.6KB, 2025-11-25 19:32:57)
        __init__.py  [Package init]  (441B, 2025-11-23 14:10:55)
        admin.py  [Router ‚Ä¢ Text/UI]  (87.8KB, 2025-11-24 00:49:16)
        common.py  [Router ‚Ä¢ Text/UI]  (15.4KB, 2025-11-26 22:27:22)
        homework.py  [Router ‚Ä¢ Text/UI]  (24.8KB, 2025-11-26 22:50:47)
        schedule.py  [Router ‚Ä¢ Text/UI]  (5.4KB, 2025-11-24 22:39:01)
        start.py  [Router ‚Ä¢ Text/UI]  (9.3KB, 2025-11-24 23:40:03)
        admin.py  [UI helper]  (8.0KB, 2025-11-24 00:49:54)
        homework.py  [UI helper]  (4.8KB, 2025-11-24 23:39:05)
        inline.py  [UI helper]  (811B, 2025-11-23 02:42:59)
        reply.py  [UI helper]  (1.9KB, 2025-11-25 19:42:11)
        admin_service.py  [Service]  (1.2KB, 2025-11-23 00:23:29)
        db.py  [Service]  (27.8KB, 2025-11-25 19:41:52)
        group_service.py  [Service]  (1.7KB, 2025-11-22 00:03:15)
        homework_service.py  [Service]  (17.9KB, 2025-11-26 22:58:38)
        schedule_service.py  [Schedule/Calendar]  (14.1KB, 2025-11-23 23:48:55)
        schedule_watchdog.py  [Schedule/Calendar]  (9.6KB, 2025-11-25 19:25:26)
        ai_logs.jsonl  [Asset]  (1.9KB, 2025-11-26 23:03:25)

=== –§–∞–π–ª—ã ===

1. app/__init__.py  (13B, 2025-11-22 00:03:17)
   –†–æ–ª—å: Package init
–ö–æ–¥:
__all__ = []

2. app/core/bot.py  (1.8KB, 2025-11-25 19:38:07)
   –†–æ–ª—å: Core
   –ò–º–ø–æ—Ä—Ç—ã (–ª–æ–∫–∞–ª—å–Ω—ã–µ): app.core.commands, app.core.config, app.core.context, app.handlers, app.handlers.start, app.services.admin_service, app.services.db, app.services.group_service, app.services.homework_service, app.services.schedule_service, app.services.schedule_watchdog
   –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ—Ç—Å—è –º–æ–¥—É–ª—è–º–∏: main
–ö–æ–¥:
from aiogram import Bot, Dispatcher

import asyncio
import datetime as dt

from app.core.config import AppConfig
from app.core.context import AppContext, set_context
from app.core.commands import get_default_bot_commands
from app.handlers import get_routers
from app.handlers.start import TosMiddleware
from app.services.admin_service import AdminPasswordService
from app.services.db import Database
from app.services.group_service import GroupResolver
from app.services.schedule_service import ScheduleService
from app.services.homework_service import HomeworkService
from app.services.schedule_watchdog import schedule_watchdog_loop


async def setup_bot(bot: Bot, dp: Dispatcher, config: AppConfig) -> None:
    db = Database(str(config.db_path))
    await db.init()
    group_resolver = GroupResolver(config.groups_path, config.group_aliases_path)
    schedule_service = ScheduleService(config.url_path)
    admin_service = AdminPasswordService(config.passwords_path)
    homework_service = HomeworkService(
        db=db,
        times_path=config.times_path,
        models_path=config.models_path,
        homeworks_dir=config.homeworks_dir,
        freeimage_api_key=config.freeimage_api_key,
        telegraph_token=config.telegraph_token,
    )
    ctx = AppContext(
        db=db,
        group_resolver=group_resolver,
        schedule_service=schedule_service,
        admin_service=admin_service,
        storage=dp.storage,
        homework_service=homework_service,
    )
    set_context(ctx)

    tz = dt.timezone(dt.timedelta(hours=3))
    asyncio.create_task(schedule_watchdog_loop(bot, tz))

    dp.message.middleware(TosMiddleware())
    dp.callback_query.middleware(TosMiddleware())
    for router in get_routers():
        dp.include_router(router)
    await bot.set_my_commands(get_default_bot_commands())

3. app/core/commands.py  (886B, 2025-11-23 14:14:55)
   –†–æ–ª—å: Core
   –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ—Ç—Å—è –º–æ–¥—É–ª—è–º–∏: app.core.bot, app.handlers.admin, app.handlers.start
–ö–æ–¥:
from aiogram.types import BotCommand


def get_default_bot_commands() -> list[BotCommand]:
    return [
        BotCommand(command="start", description="–ó–∞–ø—É—Å–∫ –±–æ—Ç–∞"),
        BotCommand(command="help", description="–°–ø—Ä–∞–≤–∫–∞"),
        BotCommand(command="setmygroup", description="–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –≥—Ä—É–ø–ø—É –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é"),
        BotCommand(command="promo", description="–ü—Ä–æ–º–æ–∫–æ–¥"),
    ]


def get_admin_bot_commands(level: int) -> list[BotCommand]:
    commands = get_default_bot_commands()
    commands.append(BotCommand(command="adminpanel", description="–ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å"))
    commands.append(BotCommand(command="ai_logs", description="–õ–æ–≥–∏ AI –¥–æ–º–∞—à–∫–∏"))
    if level >= 2:
        commands.append(BotCommand(command="givepremium", description="–í—ã–¥–∞—Ç—å –ø—Ä–µ–º–∏—É–º"))
    return commands


4. app/core/config.py  (3.1KB, 2025-11-23 14:02:50)
   –†–æ–ª—å: Core
   –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ—Ç—Å—è –º–æ–¥—É–ª—è–º–∏: app.core.bot, main
–ö–æ–¥:
import json
from dataclasses import dataclass
from pathlib import Path


@dataclass
class AppConfig:
    bot_token: str
    db_path: Path
    groups_path: Path
    group_aliases_path: Path
    url_path: Path
    passwords_path: Path
    times_path: Path
    models_path: Path
    homeworks_dir: Path
    freeimage_api_key: str | None
    telegraph_token: str | None


def load_config() -> AppConfig:
    base_dir = Path(__file__).resolve().parents[2]
    cfg_dir = base_dir / "cfg"
    cfg_dir.mkdir(parents=True, exist_ok=True)
    cfg_path = cfg_dir / "bot_config.json"
    with cfg_path.open(encoding="utf-8") as f:
        data = json.load(f)
    bot_token = data["bot_token"]
    freeimage_api_key = data.get("freeimage_api_key")
    telegraph_token = data.get("telegraph_token")
    config_dir = base_dir / "config"
    config_dir.mkdir(parents=True, exist_ok=True)
    db_path = config_dir / "nmk_bot.db"
    groups_path = config_dir / "groups.json"
    group_aliases_path = config_dir / "group_aliases.json"
    url_path = config_dir / "url.json"
    for path in (groups_path, group_aliases_path, url_path):
        if not path.exists():
            with path.open("w", encoding="utf-8") as f:
                json.dump({}, f, ensure_ascii=False, indent=2)
    passwords_path = cfg_dir / "passwords.json"
    if not passwords_path.exists():
        with passwords_path.open("w", encoding="utf-8") as f:
            json.dump({}, f, ensure_ascii=False, indent=2)
    categories_path = config_dir / "categories.json"
    if not categories_path.exists():
        with categories_path.open("w", encoding="utf-8") as f:
            json.dump({}, f, ensure_ascii=False, indent=2)
    broadcast_blocklist_path = config_dir / "broadcast_blocklist.json"
    if not broadcast_blocklist_path.exists():
        with broadcast_blocklist_path.open("w", encoding="utf-8") as f:
            json.dump({"ids": [], "usernames": []}, f, ensure_ascii=False, indent=2)
    bot_log_path = config_dir / "bot.log"
    if not bot_log_path.exists():
        bot_log_path.touch()
    user_errors_log_path = config_dir / "user_errors.log"
    if not user_errors_log_path.exists():
        user_errors_log_path.touch()
    times_path = config_dir / "times.json"
    if not times_path.exists():
        with times_path.open("w", encoding="utf-8") as f:
            json.dump({}, f, ensure_ascii=False, indent=2)
    models_path = cfg_dir / "models.json"
    if not models_path.exists():
        with models_path.open("w", encoding="utf-8") as f:
            json.dump({"models": [], "updated_at": None}, f, ensure_ascii=False, indent=2)
    homeworks_dir = config_dir / "homeworks"
    homeworks_dir.mkdir(parents=True, exist_ok=True)
    return AppConfig(
        bot_token=bot_token,
        db_path=db_path,
        groups_path=groups_path,
        group_aliases_path=group_aliases_path,
        url_path=url_path,
        passwords_path=passwords_path,
        times_path=times_path,
        models_path=models_path,
        homeworks_dir=homeworks_dir,
        freeimage_api_key=freeimage_api_key,
        telegraph_token=telegraph_token,
    )

5. app/core/constants.py  (104B, 2025-11-22 00:03:08)
   –†–æ–ª—å: Core
   –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ—Ç—Å—è –º–æ–¥—É–ª—è–º–∏: app.handlers.start, app.keyboards.inline
–ö–æ–¥:
TOS_URL = "https://telegra.ph/Polzovatelskoe-soglashenie-Publichnaya-oferta-bota-NMK-Pomoshchnik-11-09"

6. app/core/context.py  (669B, 2025-11-23 14:05:07)
   –†–æ–ª—å: Core
   –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ—Ç—Å—è –º–æ–¥—É–ª—è–º–∏: app.core.bot, app.handlers.admin, app.handlers.common, app.handlers.homework, app.handlers.schedule, app.handlers.start, app.services.schedule_watchdog
–ö–æ–¥:
from typing import Optional


class AppContext:
    def __init__(self, db, group_resolver, schedule_service, admin_service=None, storage=None, homework_service=None):
        self.db = db
        self.group_resolver = group_resolver
        self.schedule_service = schedule_service
        self.admin_service = admin_service
        self.storage = storage
        self.homework_service = homework_service


_context: Optional[AppContext] = None


def set_context(ctx: AppContext) -> None:
    global _context
    _context = ctx


def get_context() -> AppContext:
    if _context is None:
        raise RuntimeError("App context is not initialized")
    return _context

7. app/core/fsm_storage.py  (4.6KB, 2025-11-22 00:03:11)
   –†–æ–ª—å: Core
   –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ—Ç—Å—è –º–æ–¥—É–ª—è–º–∏: main
–ö–æ–¥:
import datetime as dt
import json
from collections.abc import Mapping
from typing import Any

import aiosqlite
from aiogram.fsm.storage.base import BaseStorage, StorageKey, StateType
from aiogram.fsm.state import State


class SQLiteStorage(BaseStorage):
    def __init__(self, path: str):
        self.path = path

    async def init(self) -> None:
        async with aiosqlite.connect(self.path) as db:
            await db.execute(
                """
                CREATE TABLE IF NOT EXISTS fsm_states (
                    bot_id INTEGER NOT NULL,
                    chat_id INTEGER NOT NULL,
                    user_id INTEGER NOT NULL,
                    destiny TEXT NOT NULL,
                    state TEXT,
                    updated_at TEXT NOT NULL,
                    PRIMARY KEY (bot_id, chat_id, user_id, destiny)
                )
                """
            )
            await db.execute(
                """
                CREATE TABLE IF NOT EXISTS fsm_data (
                    bot_id INTEGER NOT NULL,
                    chat_id INTEGER NOT NULL,
                    user_id INTEGER NOT NULL,
                    destiny TEXT NOT NULL,
                    data TEXT,
                    updated_at TEXT NOT NULL,
                    PRIMARY KEY (bot_id, chat_id, user_id, destiny)
                )
                """
            )
            await db.commit()

    async def close(self) -> None:
        return

    async def get_state(self, key: StorageKey) -> str | None:
        async with aiosqlite.connect(self.path) as db:
            db.row_factory = aiosqlite.Row
            cursor = await db.execute(
                "SELECT state FROM fsm_states WHERE bot_id = ? AND chat_id = ? AND user_id = ? AND destiny = ?",
                (key.bot_id, key.chat_id, key.user_id, key.destiny),
            )
            row = await cursor.fetchone()
            return row["state"] if row else None

    async def set_state(self, key: StorageKey, state: StateType = None) -> None:
        if isinstance(state, State):
            value = state.state
        else:
            value = state
        async with aiosqlite.connect(self.path) as db:
            if value is None:
                await db.execute(
                    "DELETE FROM fsm_states WHERE bot_id = ? AND chat_id = ? AND user_id = ? AND destiny = ?",
                    (key.bot_id, key.chat_id, key.user_id, key.destiny),
                )
                await db.commit()
                return
            now = dt.datetime.utcnow().isoformat()
            await db.execute(
                """
                INSERT INTO fsm_states (bot_id, chat_id, user_id, destiny, state, updated_at)
                VALUES (?, ?, ?, ?, ?, ?)
                ON CONFLICT(bot_id, chat_id, user_id, destiny)
                DO UPDATE SET state = excluded.state, updated_at = excluded.updated_at
                """,
                (key.bot_id, key.chat_id, key.user_id, key.destiny, value, now),
            )
            await db.commit()

    async def get_data(self, key: StorageKey) -> dict[str, Any]:
        async with aiosqlite.connect(self.path) as db:
            db.row_factory = aiosqlite.Row
            cursor = await db.execute(
                "SELECT data FROM fsm_data WHERE bot_id = ? AND chat_id = ? AND user_id = ? AND destiny = ?",
                (key.bot_id, key.chat_id, key.user_id, key.destiny),
            )
            row = await cursor.fetchone()
            if not row or row["data"] is None:
                return {}
            try:
                return json.loads(row["data"])
            except Exception:
                return {}

    async def set_data(self, key: StorageKey, data: Mapping[str, Any]) -> None:
        async with aiosqlite.connect(self.path) as db:
            if not data:
                await db.execute(
                    "DELETE FROM fsm_data WHERE bot_id = ? AND chat_id = ? AND user_id = ? AND destiny = ?",
                    (key.bot_id, key.chat_id, key.user_id, key.destiny),
                )
                await db.commit()
                return
            now = dt.datetime.utcnow().isoformat()
            payload = json.dumps(dict(data), ensure_ascii=False)
            await db.execute(
                """
                INSERT INTO fsm_data (bot_id, chat_id, user_id, destiny, data, updated_at)
                VALUES (?, ?, ?, ?, ?, ?)
                ON CONFLICT(bot_id, chat_id, user_id, destiny)
                DO UPDATE SET data = excluded.data, updated_at = excluded.updated_at
                """,
                (key.bot_id, key.chat_id, key.user_id, key.destiny, payload, now),
            )
            await db.commit()

8. app/core/states.py  (1.6KB, 2025-11-25 19:32:57)
   –†–æ–ª—å: Core
   –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ—Ç—Å—è –º–æ–¥—É–ª—è–º–∏: app.handlers.admin, app.handlers.common, app.handlers.homework, app.handlers.schedule, app.handlers.start
–ö–æ–¥:
from aiogram.fsm.state import StatesGroup, State


class MenuStates(StatesGroup):
    MAIN = State()
    SCHEDULE = State()


class HomeworkStates(StatesGroup):
    MENU = State()
    PERSONAL_MENU = State()
    PERSONAL_EDITOR_MENU = State()
    PERSONAL_ADD_SELECT_PAIR = State()
    PERSONAL_ADD_WAIT_CONTENT = State()
    PERSONAL_EDIT_SELECT_SUBJECT = State()
    PERSONAL_EDIT_SELECT_ACTION = State()
    PERSONAL_EDIT_WAIT_TEXT = State()
    PERSONAL_NOTIFICATIONS_MENU = State()
    PUBLIC_MENU = State()
    PUBLIC_SUGGEST_WAIT_PAIR = State()
    PUBLIC_SUGGEST_WAIT_CONTENT = State()


class PersonalCabinetStates(StatesGroup):
    MENU = State()
    SETTINGS = State()
    SETTINGS_WAIT_GROUP = State()


class AdminAuthStates(StatesGroup):
    waiting_for_password = State()


class AdminStates(StatesGroup):
    MAIN = State()
    USER_SYSTEM_MENU = State()
    USER_SEARCH = State()
    SCHEDULE_MENU = State()
    LOGS_MENU = State()
    BROADCAST_WAIT_MESSAGE = State()
    BAN_MENU = State()
    BAN_WAIT_USER = State()
    UNBAN_WAIT_USER = State()
    CATEGORIES_SELECT = State()
    CATEGORIES_CATEGORY_MENU = State()
    CATEGORY_EDIT_TEXT = State()
    MAILING_MENU = State()
    MAILING_BLOCK_WAIT_USER = State()
    MAILING_UNBLOCK_WAIT_USER = State()
    LOGS_WAIT_LINES = State()
    LOGS_WAIT_USER_ERRORS_LINES = State()
    HOMEWORK_MENU = State()
    HOMEWORK_PENDING_MENU = State()
    HOMEWORK_AI_MENU = State()
    HOMEWORK_AI_EDIT_PROMPT = State()
    HOMEWORK_STEWARDS_MENU = State()
    HOMEWORK_STEWARDS_ADD = State()
    HOMEWORK_STEWARDS_REMOVE = State()

9. app/handlers/__init__.py  (441B, 2025-11-23 14:10:55)
   –†–æ–ª—å: Package init
   –ò–º–ø–æ—Ä—Ç—ã (–ª–æ–∫–∞–ª—å–Ω—ã–µ): app.handlers.admin, app.handlers.common, app.handlers.homework, app.handlers.schedule, app.handlers.start
–ö–æ–¥:
from app.handlers.start import router as start_router
from app.handlers.common import router as common_router
from app.handlers.schedule import router as schedule_router
from app.handlers.admin import router as admin_router
from app.handlers.homework import router as homework_router


def get_routers():
    return (
        start_router,
        common_router,
        schedule_router,
        admin_router,
        homework_router,
    )

10. app/handlers/admin.py  (87.8KB, 2025-11-24 00:49:16)
   –†–æ–ª—å: Router ‚Ä¢ Text/UI
   –ò–º–ø–æ—Ä—Ç—ã (–ª–æ–∫–∞–ª—å–Ω—ã–µ): app.core.commands, app.core.context, app.core.states, app.keyboards.admin, app.keyboards.inline, app.keyboards.reply, app.services.schedule_service
   –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ—Ç—Å—è –º–æ–¥—É–ª—è–º–∏: app.handlers.__init__, app.handlers.common, app.handlers.homework
–ö–æ–¥:
import asyncio
import datetime as dt
import json
from html import escape
from pathlib import Path

import psutil
from aiogram import Router, F
from aiogram.filters import Command, CommandObject
from aiogram.fsm.context import FSMContext
from aiogram.fsm.storage.base import StorageKey
from aiogram.types import (
    Message,
    CallbackQuery,
    BotCommandScopeChat,
    FSInputFile,
    ReplyKeyboardMarkup,
    KeyboardButton,
)

from app.keyboards.admin import (
    admin_main_keyboard,
    admin_users_inline_keyboard,
    admin_sessions_keyboard,
    admin_user_system_keyboard,
    admin_schedule_keyboard,
    admin_logs_keyboard,
    admin_ban_keyboard,
    admin_mailing_keyboard,
    admin_homework_menu_keyboard,
    admin_ai_settings_keyboard,
    admin_stewards_keyboard,
    admin_pending_inline,
    admin_models_inline,
)
from app.core.states import MenuStates, AdminStates, AdminAuthStates
from app.core.commands import get_admin_bot_commands, get_default_bot_commands
from app.core.context import get_context
from app.keyboards.inline import broadcast_cancel_inline_keyboard
from app.keyboards.reply import main_menu_keyboard
from app.services.schedule_service import week_bounds_mon_sun, parse_schedule

router = Router()

MAX_ADMIN_LOGIN_ATTEMPTS = 3
ADMIN_LOGIN_BLOCK_MINUTES = 20

BASE_DIR = Path(__file__).resolve().parents[2]
CONFIG_DIR = BASE_DIR / "config"
CONFIG_DIR.mkdir(parents=True, exist_ok=True)
LOG_PATH = CONFIG_DIR / "bot.log"
FULL_LOG_PATH = CONFIG_DIR / "full_log.log"
USER_ERRORS_LOG_PATH = CONFIG_DIR / "user_errors.log"
CATEGORIES_PATH = CONFIG_DIR / "categories.json"
BROADCAST_BLOCKLIST_PATH = CONFIG_DIR / "broadcast_blocklist.json"
DEFAULT_CATEGORY_DISABLED_TEXT = "–§—É–Ω–∫—Ü–∏—è –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞."

BOT_START_TIME = dt.datetime.utcnow()


def _ensure_admin_files() -> None:
    if not LOG_PATH.exists():
        LOG_PATH.touch()
    if not USER_ERRORS_LOG_PATH.exists():
        USER_ERRORS_LOG_PATH.touch()
    if not BROADCAST_BLOCKLIST_PATH.exists():
        with BROADCAST_BLOCKLIST_PATH.open("w", encoding="utf-8") as f:
            json.dump({"ids": [], "usernames": []}, f, ensure_ascii=False, indent=2)
    if not CATEGORIES_PATH.exists():
        data = {
            "–†–∞—Å–ø–∏—Å–∞–Ω–∏–µüìã": {"enabled": True, "disabled_text": DEFAULT_CATEGORY_DISABLED_TEXT},
            "–î–æ–º–∞—à–∫–∞üìö": {"enabled": True, "disabled_text": DEFAULT_CATEGORY_DISABLED_TEXT},
        }
        with CATEGORIES_PATH.open("w", encoding="utf-8") as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


_ensure_admin_files()


def _format_users_table(rows: list[dict], start_index: int) -> str:
    headers = ["‚Ññ", "ID", "Username", "–ì—Ä—É–ø–ø–∞", "–ó–∞–±–ª–æ–∫.", "–ê–¥–º–∏–Ω"]
    body_rows: list[list[str]] = []
    for idx, u in enumerate(rows, start_index):
        body_rows.append(
            [
                str(idx),
                str(u.get("tg_id")),
                f"@{u.get('username')}" if u.get("username") else "@-",
                u.get("group_code") or "–ù–µ—Ç",
                "–î–∞" if u.get("is_blocked") else "–ù–µ—Ç",
                "–î–∞" if u.get("is_admin") else "–ù–µ—Ç",
            ]
        )
    if not body_rows:
        return "üì≠ <b>–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã.</b>"
    all_rows = [headers] + body_rows
    col_widths = [0] * len(headers)
    for row in all_rows:
        for i, value in enumerate(row):
            col_widths[i] = max(col_widths[i], len(value))

    def make_border(left: str, middle: str, right: str) -> str:
        parts = []
        for w in col_widths:
            parts.append("‚îÄ" * (w + 2))
        return left + middle.join(parts) + right

    def make_row(values: list[str]) -> str:
        parts = []
        for value, w in zip(values, col_widths):
            parts.append(" " + value.ljust(w) + " ")
        return "‚îÇ" + "‚îÇ".join(parts) + "‚îÇ"

    table_lines: list[str] = []
    table_lines.append(make_border("‚îå", "‚î¨", "‚îê"))
    table_lines.append(make_row(headers))
    table_lines.append(make_border("‚îú", "‚îº", "‚î§"))
    for row in body_rows:
        table_lines.append(make_row(row))
    table_lines.append(make_border("‚îî", "‚î¥", "‚îò"))

    header_lines = [
        "üë• <b>–°–ø–∏—Å–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π</b>",
        "",
    ]
    return "\n".join(header_lines) + "\n<pre>\n" + "\n".join(table_lines) + "\n</pre>"


def _format_admin_sessions_text(sessions: list[dict]) -> str:
    if not sessions:
        return (
            "üßë‚Äçüíª <b>–ê–∫—Ç–∏–≤–Ω—ã–µ —Å–µ—Å—Å–∏–∏ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–≤</b>\n\n"
            "–°–µ–π—á–∞—Å –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–µ—Å—Å–∏–π."
        )
    lines = ["üßë‚Äçüíª <b>–ê–∫—Ç–∏–≤–Ω—ã–µ —Å–µ—Å—Å–∏–∏ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–≤</b>", ""]
    for s in sessions:
        tg_id = s.get("tg_id")
        level = s.get("level")
        created_at = s.get("created_at")
        username = s.get("username") or ""
        if username:
            username_text = f"@{username}"
        else:
            username_text = "username –Ω–µ —É–∫–∞–∑–∞–Ω"
        name_parts = [s.get("first_name") or "", s.get("last_name") or ""]
        full_name = " ".join(p for p in name_parts if p).strip()
        if not full_name:
            full_name = "–∏–º—è –Ω–µ —É–∫–∞–∑–∞–Ω–æ"
        formatted_created = created_at
        try:
            dt_obj = dt.datetime.fromisoformat(created_at)
            formatted_created = dt_obj.strftime("%d.%m.%Y %H:%M")
        except Exception:
            pass
        lines.append(
            f"‚Ä¢ <code>{tg_id}</code> ‚Äî {username_text}, {full_name}\n"
            f"  –£—Ä–æ–≤–µ–Ω—å: <b>{level}</b>, —Å–µ—Å—Å–∏—è —Å: <code>{formatted_created}</code>"
        )
    return "\n".join(lines)


def _load_categories_config() -> dict:
    try:
        with CATEGORIES_PATH.open(encoding="utf-8") as f:
            data = json.load(f)
    except FileNotFoundError:
        data = {}
    if not isinstance(data, dict):
        data = {}
    changed = False
    if "–†–∞—Å–ø–∏—Å–∞–Ω–∏–µüìã" not in data:
        data["–†–∞—Å–ø–∏—Å–∞–Ω–∏–µüìã"] = {"enabled": True, "disabled_text": DEFAULT_CATEGORY_DISABLED_TEXT}
        changed = True
    if "–î–æ–º–∞—à–∫–∞üìö" not in data:
        data["–î–æ–º–∞—à–∫–∞üìö"] = {"enabled": True, "disabled_text": DEFAULT_CATEGORY_DISABLED_TEXT}
        changed = True
    if changed:
        _save_categories_config(data)
    return data


def _save_categories_config(data: dict) -> None:
    CATEGORIES_PATH.parent.mkdir(parents=True, exist_ok=True)
    with CATEGORIES_PATH.open("w", encoding="utf-8") as f:
        json.dump(data, f, ensure_ascii=False, indent=2)


def _categories_list_keyboard(categories: list[str]) -> ReplyKeyboardMarkup:
    rows: list[list[KeyboardButton]] = []
    for name in sorted(categories):
        rows.append([KeyboardButton(text=name)])
    rows.append([KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –≤ –∞–¥–º–∏–Ω-–º–µ–Ω—é")])
    return ReplyKeyboardMarkup(keyboard=rows, resize_keyboard=True)


def _category_menu_keyboard(enabled: bool) -> ReplyKeyboardMarkup:
    rows: list[list[KeyboardButton]] = []
    if enabled:
        rows.append([KeyboardButton(text="‚õî –í—ã–∫–ª—é—á–∏—Ç—å")])
    else:
        rows.append([KeyboardButton(text="‚úÖ –í–∫–ª—é—á–∏—Ç—å")])
    rows.append([KeyboardButton(text="‚úèÔ∏è –¢–µ–∫—Å—Ç –ø—Ä–∏ –æ—Ç–∫–ª—é—á–µ–Ω–∏–∏")])
    rows.append([KeyboardButton(text="üîô –í—ã–±—Ä–∞—Ç—å –¥—Ä—É–≥—É—é –∫–∞—Ç–µ–≥–æ—Ä–∏—é")])
    rows.append([KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –≤ –∞–¥–º–∏–Ω-–º–µ–Ω—é")])
    return ReplyKeyboardMarkup(keyboard=rows, resize_keyboard=True)


def _load_broadcast_blocklist() -> dict:
    try:
        with BROADCAST_BLOCKLIST_PATH.open(encoding="utf-8") as f:
            data = json.load(f)
    except FileNotFoundError:
        data = {}
    if not isinstance(data, dict):
        data = {}
    ids = data.get("ids") or []
    usernames = data.get("usernames") or []
    ids_out: list[int] = []
    for v in ids:
        try:
            ids_out.append(int(v))
        except Exception:
            continue
    usernames_out: list[str] = []
    for u in usernames:
        if isinstance(u, str) and u:
            usernames_out.append(u.lower())
    return {"ids": ids_out, "usernames": usernames_out}


def _save_broadcast_blocklist(data: dict) -> None:
    ids = [int(v) for v in data.get("ids", [])]
    usernames = []
    for u in data.get("usernames", []):
        if isinstance(u, str) and u:
            usernames.append(u.lower())
    BROADCAST_BLOCKLIST_PATH.parent.mkdir(parents=True, exist_ok=True)
    with BROADCAST_BLOCKLIST_PATH.open("w", encoding="utf-8") as f:
        json.dump({"ids": ids, "usernames": usernames}, f, ensure_ascii=False, indent=2)


async def _check_admin_block_before_login(message: Message) -> bool:
    ctx = get_context()
    limits = await ctx.db.get_admin_login_limits(message.from_user.id)
    if not limits:
        return False
    blocked_until_str = limits.get("blocked_until")
    if not blocked_until_str:
        return False
    try:
        blocked_until = dt.datetime.fromisoformat(blocked_until_str)
    except Exception:
        await ctx.db.clear_admin_login_limits(message.from_user.id)
        return False
    now = dt.datetime.utcnow()
    if blocked_until <= now:
        await ctx.db.clear_admin_login_limits(message.from_user.id)
        return False
    remaining = blocked_until - now
    seconds = int(remaining.total_seconds())
    minutes = max(1, seconds // 60 or 1)
    await message.answer(
        "üö´ <b>–í—Ö–æ–¥ –≤ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å –≤—Ä–µ–º–µ–Ω–Ω–æ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω</b>\n\n"
        f"–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑ —á–µ—Ä–µ–∑ –ø—Ä–∏–º–µ—Ä–Ω–æ <b>{minutes}</b> –º–∏–Ω."
    )
    return True


async def _register_failed_admin_login(message: Message, state: FSMContext) -> None:
    ctx = get_context()
    db = ctx.db
    now = dt.datetime.utcnow()
    limits = await db.get_admin_login_limits(message.from_user.id)
    attempts_left = MAX_ADMIN_LOGIN_ATTEMPTS
    if limits:
        blocked_until_str = limits.get("blocked_until")
        if blocked_until_str:
            try:
                blocked_until = dt.datetime.fromisoformat(blocked_until_str)
            except Exception:
                blocked_until = None
            if blocked_until and blocked_until > now:
                remaining = blocked_until - now
                seconds = int(remaining.total_seconds())
                minutes = max(1, seconds // 60 or 1)
                await message.answer(
                    "üö´ <b>–í—Ö–æ–¥ –≤ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å –≤—Ä–µ–º–µ–Ω–Ω–æ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω</b>\n\n"
                    f"–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑ —á–µ—Ä–µ–∑ –ø—Ä–∏–º–µ—Ä–Ω–æ <b>{minutes}</b> –º–∏–Ω."
                )
                return
            else:
                limits = None
    if limits:
        attempts_left = int(limits.get("attempts_left", MAX_ADMIN_LOGIN_ATTEMPTS))
    new_attempts_left = attempts_left - 1
    if new_attempts_left <= 0:
        blocked_until = now + dt.timedelta(minutes=ADMIN_LOGIN_BLOCK_MINUTES)
        await db.set_admin_login_limits(
            message.from_user.id,
            attempts_left=0,
            blocked_until=blocked_until.isoformat(),
        )
        await message.answer(
            "üö´ <b>–í—ã –∏—Å—á–µ—Ä–ø–∞–ª–∏ –≤—Å–µ –ø–æ–ø—ã—Ç–∫–∏ –≤—Ö–æ–¥–∞</b>.\n\n"
            f"–í—Ö–æ–¥ –≤ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω –Ω–∞ <b>{ADMIN_LOGIN_BLOCK_MINUTES}</b> –º–∏–Ω—É—Ç."
        )
        await state.set_state(MenuStates.MAIN)
        await message.bot.set_my_commands(
            get_default_bot_commands(),
            scope=BotCommandScopeChat(chat_id=message.chat.id),
        )
        await message.answer(
            "–í—ã –±—ã–ª–∏ –≤–æ–∑–≤—Ä–∞—â–µ–Ω—ã –≤ –æ–±—ã—á–Ω–æ–µ –º–µ–Ω—é.",
            reply_markup=main_menu_keyboard(),
        )
        return
    await db.set_admin_login_limits(
        message.from_user.id,
        attempts_left=new_attempts_left,
        blocked_until=None,
    )
    await message.answer(
        "‚ùå <b>–ù–µ–≤–µ—Ä–Ω—ã–π –ø–∞—Ä–æ–ª—å.</b>\n"
        f"–û—Å—Ç–∞–ª–æ—Å—å –ø–æ–ø—ã—Ç–æ–∫: <b>{new_attempts_left}</b> –∏–∑ {MAX_ADMIN_LOGIN_ATTEMPTS}."
    )


async def _ensure_admin_session_message(message: Message, state: FSMContext, min_level: int = 1) -> dict | None:
    ctx = get_context()
    session = await ctx.db.get_active_admin_session_for_user(message.from_user.id)
    if not session:
        await state.set_state(MenuStates.MAIN)
        await message.bot.set_my_commands(
            get_default_bot_commands(),
            scope=BotCommandScopeChat(chat_id=message.chat.id),
        )
        await message.answer(
            "‚ö†Ô∏è <b>–°–µ—Å—Å–∏—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞ –Ω–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–∞.</b>\n"
            "–í—ã –±—ã–ª–∏ –≤–æ–∑–≤—Ä–∞—â–µ–Ω—ã –≤ –æ–±—ã—á–Ω–æ–µ –º–µ–Ω—é.",
            reply_markup=main_menu_keyboard(),
        )
        return None
    if session.get("level", 0) < min_level:
        await message.answer("‚õî <b>–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤</b> –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —ç—Ç–æ–≥–æ –¥–µ–π—Å—Ç–≤–∏—è.")
        return None
    return session


async def _ensure_admin_session_callback(callback: CallbackQuery, state: FSMContext, min_level: int = 1) -> dict | None:
    ctx = get_context()
    session = await ctx.db.get_active_admin_session_for_user(callback.from_user.id)
    if not session:
        await state.set_state(MenuStates.MAIN)
        await callback.bot.set_my_commands(
            get_default_bot_commands(),
            scope=BotCommandScopeChat(chat_id=callback.message.chat.id),
        )
        await callback.message.answer(
            "‚ö†Ô∏è <b>–°–µ—Å—Å–∏—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞ –Ω–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–∞.</b>\n"
            "–í—ã –±—ã–ª–∏ –≤–æ–∑–≤—Ä–∞—â–µ–Ω—ã –≤ –æ–±—ã—á–Ω–æ–µ –º–µ–Ω—é.",
            reply_markup=main_menu_keyboard(),
        )
        await callback.answer()
        return None
    if session.get("level", 0) < min_level:
        await callback.answer("‚õî –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤.", show_alert=True)
        return None
    return session


async def _process_admin_login(message: Message, state: FSMContext, password: str) -> None:
    password = (password or "").strip()
    if not password:
        await message.answer(
            "‚ö†Ô∏è –ü–∞—Ä–æ–ª—å –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º.\n"
            "–û—Ç–ø—Ä–∞–≤—å—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –ø–∞—Ä–æ–ª—å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞ –æ–¥–Ω–∏–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º."
        )
        return
    ctx = get_context()
    if ctx.admin_service is None:
        await state.clear()
        await state.set_state(MenuStates.MAIN)
        await message.bot.set_my_commands(
            get_default_bot_commands(),
            scope=BotCommandScopeChat(chat_id=message.chat.id),
        )
        await message.answer(
            "‚ö†Ô∏è <b>–ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å —Å–µ–π—á–∞—Å –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞.</b>\n"
            "–í—ã –±—ã–ª–∏ –≤–æ–∑–≤—Ä–∞—â–µ–Ω—ã –≤ –æ–±—ã—á–Ω–æ–µ –º–µ–Ω—é.",
            reply_markup=main_menu_keyboard(),
        )
        return
    level = ctx.admin_service.get_level_for_password(password)
    if not level:
        await _register_failed_admin_login(message, state)
        return
    await ctx.db.clear_admin_login_limits(message.from_user.id)
    existing_by_password = await ctx.db.get_active_admin_session_by_password(password)
    if existing_by_password and existing_by_password["tg_id"] != message.from_user.id:
        await message.answer(
            "‚ö†Ô∏è –î–∞–Ω–Ω—ã–π –ø–∞—Ä–æ–ª—å —É–∂–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥—Ä—É–≥–∏–º –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º.\n"
            "–î–æ–∂–¥–∏—Ç–µ—Å—å –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –µ–≥–æ —Å–µ—Å—Å–∏–∏."
        )
        return
    await ctx.db.deactivate_admin_sessions_for_user(message.from_user.id)
    await ctx.db.create_admin_session(message.from_user.id, level, password)
    await state.set_state(AdminStates.MAIN)
    await message.bot.set_my_commands(
        get_admin_bot_commands(level),
        scope=BotCommandScopeChat(chat_id=message.chat.id),
    )
    await message.answer(
        f"‚úÖ <b>–í—Ö–æ–¥ –≤ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å –≤—ã–ø–æ–ª–Ω–µ–Ω.</b>\n"
        f"–í–∞—à —É—Ä–æ–≤–µ–Ω—å –¥–æ—Å—Ç—É–ø–∞: <b>{level}</b>.",
        reply_markup=admin_main_keyboard(level),
    )


@router.message(Command("givepremium"))
async def cmd_givepremium(message: Message, command: CommandObject, state: FSMContext) -> None:
    ctx = get_context()
    session = await ctx.db.get_active_admin_session_for_user(message.from_user.id)
    if not session or session.get("level", 0) < 2:
        await message.answer("‚õî –ö–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞–º —É—Ä–æ–≤–Ω—è 2+.")
        return
    args = (command.args or "").strip()
    if not args:
        await message.answer(
            "–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: <code>/givepremium @username 60d</code> –∏–ª–∏ <code>/givepremium 123456789 15d</code>."
        )
        return
    parts = args.split()
    if len(parts) != 2:
        await message.answer(
            "–ù—É–∂–Ω–æ —É–∫–∞–∑–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏ —Å—Ä–æ–∫. –ü—Ä–∏–º–µ—Ä: <code>/givepremium @user 30d</code>."
        )
        return
    ident, period = parts
    if not period.endswith("d"):
        await message.answer("–°—Ä–æ–∫ —É–∫–∞–∑—ã–≤–∞–µ—Ç—Å—è –≤ –¥–Ω—è—Ö, –Ω–∞–ø—Ä–∏–º–µ—Ä: <code>30d</code>.")
        return
    try:
        days = int(period[:-1])
    except Exception:
        await message.answer("–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Å—Ä–æ–∫–∞. –ü—Ä–∏–º–µ—Ä: <code>30d</code>.")
        return
    if days <= 0:
        await message.answer("–°—Ä–æ–∫ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –±–æ–ª—å—à–µ –Ω—É–ª—è.")
        return
    tg_id: int | None = None
    if ident.lstrip("@").isdigit():
        tg_id = int(ident.lstrip("@"))
    else:
        username = ident.lstrip("@").lower()
        users = await ctx.db.search_users(username)
        if not users:
            await message.answer("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º username –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –±–∞–∑–µ.")
            return
        tg_id = users[0].get("tg_id")
    if not tg_id:
        await message.answer("–ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.")
        return
    until = dt.datetime.utcnow() + dt.timedelta(days=days)
    await ctx.db.set_user_premium(tg_id, until)
    until_str = until.strftime("%d.%m.%Y")
    await message.answer(
        f"‚úÖ –ü—Ä–µ–º–∏—É–º –≤—ã–¥–∞–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é <code>{tg_id}</code> –¥–æ <b>{until_str}</b>."
    )


@router.message(Command("ai_logs"))
async def cmd_ai_logs(message: Message, state: FSMContext) -> None:
    ctx = get_context()
    session = await ctx.db.get_active_admin_session_for_user(message.from_user.id)
    if not session:
        await message.answer("‚õî –î–æ—Å—Ç—É–ø–Ω–æ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞–º.")
        return
    page = 1
    logs, total, pages = ctx.homework_service.load_ai_logs_page(page, per_page=5)
    if total == 0:
        await message.answer("–õ–æ–≥–∏ AI-–ø—Ä–æ–≤–µ—Ä–∫–∏ –¥–æ–º–∞—à–∫–∏ –ø—É—Å—Ç—ã.")
        return
    lines: list[str] = ["üß† <b>–õ–æ–≥–∏ AI-–ø—Ä–æ–≤–µ—Ä–∫–∏ –¥–æ–º–∞—à–∫–∏</b>", ""]
    for item in logs:
        user_id = item.get("user_id")
        username = item.get("username")
        full_name = item.get("full_name")
        subject = item.get("subject")
        text = item.get("text")
        telegraph_url = item.get("telegraph_url")
        ai_res = item.get("ai_result") or {}
        decision = ai_res.get("decision")
        raw = ai_res.get("raw")
        user_line = f"ID: <code>{user_id}</code>"
        if username:
            user_line += f" (@{username})"
        if full_name:
            user_line += f" ‚Äî {escape(full_name)}"
        lines.append(user_line)
        lines.append(f"–ü—Ä–µ–¥–º–µ—Ç: <b>{escape(subject or '')}</b>")
        lines.append(f"–¢–µ–∫—Å—Ç: {escape(text or '')}")
        if telegraph_url:
            lines.append(f"–§–æ—Ç–æ: {escape(telegraph_url)}")
        lines.append(f"–û—Ç–≤–µ—Ç –Ω–µ–π—Ä–æ—Å–µ—Ç–∏: {escape(str(raw)[:800])}")
        lines.append("")
    lines.append(f"–ü–æ–∫–∞–∑–∞–Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–∞ 1 –∏–∑ {pages}. –ü–æ–¥–¥–µ—Ä–∂–∫–∞ –ø–æ—Å—Ç—Ä–∞–Ω–∏—á–Ω–æ–π –Ω–∞–≤–∏–≥–∞—Ü–∏–∏ –±—É–¥–µ—Ç –¥–æ–±–∞–≤–ª–µ–Ω–∞ –æ—Ç–¥–µ–ª—å–Ω–æ.")
    await message.answer("\n".join(lines))


@router.message(Command("adminpanel"))
async def cmd_adminpanel(message: Message, state: FSMContext) -> None:
    ctx = get_context()
    admin_session = await ctx.db.get_active_admin_session_for_user(message.from_user.id)
    if admin_session:
        await state.set_state(AdminStates.MAIN)
        await message.bot.set_my_commands(
            get_admin_bot_commands(admin_session["level"]),
            scope=BotCommandScopeChat(chat_id=message.chat.id),
        )
        await message.answer(
            "üõ† <b>–ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å —É–∂–µ –∞–∫—Ç–∏–≤–Ω–∞.</b>\n"
            "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫–∏ –º–µ–Ω—é –Ω–∏–∂–µ.",
            reply_markup=admin_main_keyboard(admin_session["level"]),
        )
        return
    if await _check_admin_block_before_login(message):
        return
    parts = (message.text or "").split(maxsplit=1)
    if len(parts) > 1:
        await _process_admin_login(message, state, parts[1])
        return
    await state.set_state(AdminAuthStates.waiting_for_password)
    await message.answer(
        "<b>–í—Ö–æ–¥ –≤ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å</b>\n\n"
        "–û—Ç–ø—Ä–∞–≤—å—Ç–µ –ø–∞—Ä–æ–ª—å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞ –æ–¥–Ω–∏–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º."
    )


@router.message(AdminAuthStates.waiting_for_password)
async def adminpanel_password_input(message: Message, state: FSMContext) -> None:
    await _process_admin_login(message, state, message.text or "")


@router.message(AdminStates.MAIN, F.text == "üìö –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –¥–æ–º–∞—à–∫–æ–π")
async def admin_homework_menu(message: Message, state: FSMContext) -> None:
    session = await _ensure_admin_session_message(message, state, min_level=2)
    if not session:
        return
    await state.set_state(AdminStates.HOMEWORK_MENU)
    await message.answer("üìö <b>–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –¥–æ–º–∞—à–∫–æ–π</b>", reply_markup=admin_homework_menu_keyboard())


@router.message(AdminStates.HOMEWORK_MENU, F.text == "‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –≤ –∞–¥–º–∏–Ω-–º–µ–Ω—é")
async def admin_homework_back(message: Message, state: FSMContext) -> None:
    session = await _ensure_admin_session_message(message, state, min_level=2)
    if not session:
        return
    await state.set_state(AdminStates.MAIN)
    await message.answer("–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", reply_markup=admin_main_keyboard(session["level"]))


@router.message(AdminStates.HOMEWORK_MENU, F.text == "üß† AI –ù–∞—Å—Ç—Ä–æ–π–∫–∏")
async def admin_ai_settings(message: Message, state: FSMContext) -> None:
    session = await _ensure_admin_session_message(message, state, min_level=2)
    if not session:
        return
    ctx = get_context()
    config = ctx.homework_service.load_ai_config()
    auto_accept = config.get("auto_accept", False)
    await state.set_state(AdminStates.HOMEWORK_AI_MENU)
    await message.answer(
        f"üß† <b>AI –ù–∞—Å—Ç—Ä–æ–π–∫–∏</b>\n\n–ú–æ–¥–µ–ª—å: {config.get('model')}\n–¢–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞: {config.get('temperature')}\n–ê–≤—Ç–æ-–ø—Ä–∏–Ω—è—Ç–∏–µ: {auto_accept}",
        reply_markup=admin_ai_settings_keyboard(auto_accept)
    )


@router.message(AdminStates.HOMEWORK_AI_MENU, F.text == "üìù –°–∏—Å—Ç–µ–º–Ω—ã–π –ø—Ä–æ–º—Ç")
async def admin_ai_edit_prompt(message: Message, state: FSMContext) -> None:
    ctx = get_context()
    config = ctx.homework_service.load_ai_config()
    await state.set_state(AdminStates.HOMEWORK_AI_EDIT_PROMPT)
    await message.answer(f"–¢–µ–∫—É—â–∏–π –ø—Ä–æ–º—Ç:\n<code>{config.get('system_prompt')}</code>\n\n–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤—ã–π –ø—Ä–æ–º—Ç:")


@router.message(AdminStates.HOMEWORK_AI_EDIT_PROMPT)
async def admin_ai_save_prompt(message: Message, state: FSMContext) -> None:
    ctx = get_context()
    config = ctx.homework_service.load_ai_config()
    config["system_prompt"] = message.text
    ctx.homework_service.save_ai_config(config)
    await state.set_state(AdminStates.HOMEWORK_AI_MENU)
    await message.answer("–ü—Ä–æ–º—Ç –æ–±–Ω–æ–≤–ª–µ–Ω", reply_markup=admin_ai_settings_keyboard(config.get("auto_accept")))


@router.message(AdminStates.HOMEWORK_AI_MENU, F.text.contains("–ê–≤—Ç–æ-–ø—Ä–∏–Ω—è—Ç–∏–µ"))
async def admin_ai_toggle_auto(message: Message, state: FSMContext) -> None:
    ctx = get_context()
    config = ctx.homework_service.load_ai_config()
    config["auto_accept"] = not config.get("auto_accept", False)
    ctx.homework_service.save_ai_config(config)
    await message.answer("–ù–∞—Å—Ç—Ä–æ–π–∫–∞ –∏–∑–º–µ–Ω–µ–Ω–∞", reply_markup=admin_ai_settings_keyboard(config["auto_accept"]))


@router.message(AdminStates.HOMEWORK_AI_MENU, F.text == "üîÑ –û–±–Ω–æ–≤–∏—Ç—å —Å–ø–∏—Å–æ–∫ –º–æ–¥–µ–ª–µ–π")
async def admin_ai_refresh_models(message: Message, state: FSMContext) -> None:
    ctx = get_context()
    await message.answer("–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞...")
    models = await ctx.homework_service.pollinations_refresh_models()
    await message.answer(f"–ó–∞–≥—Ä—É–∂–µ–Ω–æ {len(models)} –º–æ–¥–µ–ª–µ–π.")


@router.message(AdminStates.HOMEWORK_AI_MENU, F.text == "ü§ñ –í—ã–±—Ä–∞—Ç—å –º–æ–¥–µ–ª—å")
async def admin_ai_select_model(message: Message, state: FSMContext) -> None:
    ctx = get_context()
    models = ctx.homework_service.load_models()
    if not models:
        models = await ctx.homework_service.pollinations_refresh_models()
    await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –º–æ–¥–µ–ª—å:", reply_markup=admin_models_inline(models[:10]))


@router.callback_query(F.data.startswith("ai_model:"))
async def admin_ai_model_callback(callback: CallbackQuery, state: FSMContext) -> None:
    model = callback.data.split(":", 1)[1]
    ctx = get_context()
    config = ctx.homework_service.load_ai_config()
    config["model"] = model
    ctx.homework_service.save_ai_config(config)
    await callback.answer(f"–ú–æ–¥–µ–ª—å {model} –≤—ã–±—Ä–∞–Ω–∞")
    await callback.message.delete()


@router.message(AdminStates.HOMEWORK_AI_MENU, F.text == "‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –≤ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –¥–æ–º–∞—à–∫–æ–π")
async def admin_ai_back_to_homework(message: Message, state: FSMContext) -> None:
    session = await _ensure_admin_session_message(message, state, min_level=2)
    if not session:
        return
    await state.set_state(AdminStates.HOMEWORK_MENU)
    await message.answer("üìö –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –¥–æ–º–∞—à–∫–æ–π", reply_markup=admin_homework_menu_keyboard())


@router.message(AdminStates.HOMEWORK_MENU, F.text == "‚è≥ –û—á–µ—Ä–µ–¥—å –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–Ω—ã—Ö –î–ó")
async def admin_homework_queue(message: Message, state: FSMContext) -> None:
    ctx = get_context()
    items, total, pages = ctx.homework_service.load_public_pending_page(1)
    if not items:
        await message.answer("–û—á–µ—Ä–µ–¥—å –ø—É—Å—Ç–∞")
        return
    for item in items:
        text = f"–ü—Ä–µ–¥–ª–æ–∂–∏–ª: {item.get('username')}\n–ü—Ä–µ–¥–º–µ—Ç: {item.get('subject')}\n–¢–µ–∫—Å—Ç: {item.get('text')}\nAI: {item.get('ai_result', {}).get('raw')}"
        await message.answer(text, reply_markup=admin_pending_inline(item["id"]))


@router.callback_query(F.data.startswith("hw_apr:"))
async def admin_approve_hw(callback: CallbackQuery) -> None:
    req_id = callback.data.split(":")[1]
    ctx = get_context()
    item = ctx.homework_service.get_pending_request(req_id)
    if item:
        await ctx.homework_service.add_public_homework(item["group_code"], item["subject"], item["text"], item["telegraph_url"])
        ctx.homework_service.remove_pending_request(req_id)
        await callback.message.edit_text("‚úÖ –û–¥–æ–±—Ä–µ–Ω–æ")
    else:
        await callback.answer("–ó–∞—è–≤–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")


@router.callback_query(F.data.startswith("hw_rej:"))
async def admin_reject_hw(callback: CallbackQuery) -> None:
    req_id = callback.data.split(":")[1]
    ctx = get_context()
    ctx.homework_service.remove_pending_request(req_id)
    await callback.message.edit_text("‚ùå –û—Ç–∫–ª–æ–Ω–µ–Ω–æ")


@router.message(AdminStates.HOMEWORK_MENU, F.text == "üëÆ –°—Ç–∞—Ä–æ—Å—Ç—ã")
async def admin_stewards_menu(message: Message, state: FSMContext) -> None:
    session = await _ensure_admin_session_message(message, state, min_level=2)
    if not session:
        return
    await state.set_state(AdminStates.HOMEWORK_STEWARDS_MENU)
    await message.answer("–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ä–æ—Å—Ç–∞–º–∏", reply_markup=admin_stewards_keyboard())


@router.message(AdminStates.HOMEWORK_STEWARDS_MENU, F.text == "‚ûï –ù–∞–∑–Ω–∞—á–∏—Ç—å —Å—Ç–∞—Ä–æ—Å—Ç—É")
async def admin_stewards_add(message: Message, state: FSMContext) -> None:
    await state.set_state(AdminStates.HOMEWORK_STEWARDS_ADD)
    await message.answer("–í–≤–µ–¥–∏—Ç–µ ID –∏–ª–∏ Username –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏ –∫–æ–¥ –≥—Ä—É–ø–ø—ã. –ü—Ä–∏–º–µ—Ä: @user –ò–°-131")


@router.message(AdminStates.HOMEWORK_STEWARDS_ADD)
async def admin_stewards_add_process(message: Message, state: FSMContext) -> None:
    text = message.text or ""
    if text == "‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –≤ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –¥–æ–º–∞—à–∫–æ–π":
        session = await _ensure_admin_session_message(message, state, min_level=2)
        if not session:
            return
        await state.set_state(AdminStates.HOMEWORK_MENU)
        await message.answer("üìö –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –¥–æ–º–∞—à–∫–æ–π", reply_markup=admin_homework_menu_keyboard())
        return
    parts = text.split()
    if len(parts) < 2:
        await message.answer("–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç. –ü—Ä–∏–º–µ—Ä: @user –ò–°-131")
        return
    ident, group = parts[0], parts[1]
    ctx = get_context()
    if ident.lstrip("@").isdigit():
        uid = int(ident.lstrip("@"))
    else:
        users = await ctx.db.search_users(ident)
        if not users:
            await message.answer("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω")
            return
        uid = users[0]["tg_id"]
    await ctx.db.set_steward(uid, group)
    await message.answer(f"–°—Ç–∞—Ä–æ—Å—Ç–∞ –¥–ª—è {group} –Ω–∞–∑–Ω–∞—á–µ–Ω")
    await state.set_state(AdminStates.HOMEWORK_STEWARDS_MENU)
    await message.answer("–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ä–æ—Å—Ç–∞–º–∏", reply_markup=admin_stewards_keyboard())


@router.message(AdminStates.HOMEWORK_STEWARDS_MENU, F.text == "‚ûñ –°–Ω—è—Ç—å —Å—Ç–∞—Ä–æ—Å—Ç—É")
async def admin_stewards_remove_start(message: Message, state: FSMContext) -> None:
    await state.set_state(AdminStates.HOMEWORK_STEWARDS_REMOVE)
    await message.answer("–í–≤–µ–¥–∏—Ç–µ ID –∏–ª–∏ Username –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, –∫–æ—Ç–æ—Ä–æ–≥–æ –Ω—É–∂–Ω–æ —Å–Ω—è—Ç—å —Å —Ä–æ–ª–∏ —Å—Ç–∞—Ä–æ—Å—Ç—ã.")


@router.message(AdminStates.HOMEWORK_STEWARDS_REMOVE)
async def admin_stewards_remove_process(message: Message, state: FSMContext) -> None:
    text = (message.text or "").strip()
    if text == "‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –≤ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –¥–æ–º–∞—à–∫–æ–π":
        session = await _ensure_admin_session_message(message, state, min_level=2)
        if not session:
            return
        await state.set_state(AdminStates.HOMEWORK_MENU)
        await message.answer("üìö –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –¥–æ–º–∞—à–∫–æ–π", reply_markup=admin_homework_menu_keyboard())
        return
    if not text:
        await message.answer("–£–∫–∞–∂–∏—Ç–µ ID –∏–ª–∏ username –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.")
        return
    ctx = get_context()
    if text.lstrip("@").isdigit():
        uid = int(text.lstrip("@"))
    else:
        users = await ctx.db.search_users(text)
        if not users:
            await message.answer("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω.")
            return
        uid = users[0]["tg_id"]
    await ctx.db.remove_steward(uid)
    await state.set_state(AdminStates.HOMEWORK_STEWARDS_MENU)
    await message.answer("–°—Ç–∞—Ä–æ—Å—Ç–∞ —Å–Ω—è—Ç.", reply_markup=admin_stewards_keyboard())


@router.message(AdminStates.HOMEWORK_STEWARDS_MENU, F.text == "üìã –°–ø–∏—Å–æ–∫ —Å—Ç–∞—Ä–æ—Å—Ç")
async def admin_stewards_list(message: Message, state: FSMContext) -> None:
    session = await _ensure_admin_session_message(message, state, min_level=2)
    if not session:
        return
    ctx = get_context()
    items = await ctx.db.list_stewards()
    if not items:
        await message.answer("–°–ø–∏—Å–æ–∫ —Å—Ç–∞—Ä–æ—Å—Ç –ø—É—Å—Ç.", reply_markup=admin_stewards_keyboard())
        return
    lines = ["üìã <b>–°–ø–∏—Å–æ–∫ —Å—Ç–∞—Ä–æ—Å—Ç</b>", ""]
    for item in items:
        tg_id = item.get("tg_id")
        group_code = item.get("group_code")
        username = item.get("username")
        first_name = item.get("first_name") or ""
        last_name = item.get("last_name") or ""
        name = " ".join(p for p in [first_name, last_name] if p).strip()
        ident = f"<code>{tg_id}</code>"
        if username:
            ident += f" (@{username})"
        if name:
            ident += f" ‚Äî {escape(name)}"
        lines.append(f"{ident} ‚Äî –≥—Ä—É–ø–ø–∞ <b>{escape(str(group_code))}</b>")
    await message.answer("\n".join(lines), reply_markup=admin_stewards_keyboard())


@router.message(
    AdminStates.HOMEWORK_STEWARDS_MENU,
    F.text == "‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –≤ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –¥–æ–º–∞—à–∫–æ–π",
)
@router.message(
    AdminStates.HOMEWORK_STEWARDS_ADD,
    F.text == "‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –≤ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –¥–æ–º–∞—à–∫–æ–π",
)
@router.message(
    AdminStates.HOMEWORK_STEWARDS_REMOVE,
    F.text == "‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –≤ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –¥–æ–º–∞—à–∫–æ–π",
)
async def admin_stewards_back_to_homework(message: Message, state: FSMContext) -> None:
    session = await _ensure_admin_session_message(message, state, min_level=2)
    if not session:
        return
    await state.set_state(AdminStates.HOMEWORK_MENU)
    await message.answer("üìö –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –¥–æ–º–∞—à–∫–æ–π", reply_markup=admin_homework_menu_keyboard())


@router.message(AdminStates.MAIN, F.text == "üß© –°–∏—Å—Ç–µ–º–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π")
async def admin_user_system_menu(message: Message, state: FSMContext) -> None:
    session = await _ensure_admin_session_message(message, state)
    if not session:
        return
    level = session.get("level", 1)
    await state.set_state(AdminStates.USER_SYSTEM_MENU)
    await message.answer(
        "üë• <b>–°–∏—Å—Ç–µ–º–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π</b>\n\n"
        "–í—ã–±–µ—Ä–∏—Ç–µ –Ω—É–∂–Ω—ã–π —Ä–∞–∑–¥–µ–ª:",
        reply_markup=admin_user_system_keyboard(level),
    )


@router.message(AdminStates.USER_SYSTEM_MENU, F.text == "‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –≤ –∞–¥–º–∏–Ω-–º–µ–Ω—é")
async def admin_user_system_back(message: Message, state: FSMContext) -> None:
    session = await _ensure_admin_session_message(message, state)
    if not session:
        return
    level = session.get("level", 1)
    await state.set_state(AdminStates.MAIN)
    await message.answer(
        "üîô –í—ã –≤–µ—Ä–Ω—É–ª–∏—Å—å –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª–∏.",
        reply_markup=admin_main_keyboard(level),
    )


@router.message(AdminStates.USER_SYSTEM_MENU, F.text == "üë• –°–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π")
async def admin_users_list(message: Message, state: FSMContext) -> None:
    session = await _ensure_admin_session_message(message, state)
    if not session:
        return
    ctx = get_context()
    page = 1
    per_page = 20
    users, total, pages = await ctx.db.list_users_page(page, per_page)
    if not users or total == 0:
        await message.answer("üì≠ <b>–°–ø–∏—Å–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –ø—É—Å—Ç.</b>")
        return
    text = _format_users_table(users, start_index=1)
    markup = admin_users_inline_keyboard(page, pages)
    await message.answer(text, reply_markup=markup)


@router.message(AdminStates.USER_SYSTEM_MENU, F.text == "üîç –ü–æ–∏—Å–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è")
async def admin_search_start(message: Message, state: FSMContext) -> None:
    session = await _ensure_admin_session_message(message, state)
    if not session:
        return
    await state.set_state(AdminStates.USER_SEARCH)
    await message.answer(
        "üîç <b>–ü–æ–∏—Å–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è</b>\n\n"
        "–û—Ç–ø—Ä–∞–≤—å—Ç–µ username (—Å @ –∏–ª–∏ –±–µ–∑) –∏–ª–∏ —á–∏—Å–ª–æ–≤–æ–π ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è."
    )


@router.message(AdminStates.USER_SEARCH)
async def admin_search_process(message: Message, state: FSMContext) -> None:
    session = await _ensure_admin_session_message(message, state)
    if not session:
        return
    query = (message.text or "").strip()
    if not query:
        await message.answer("‚ö†Ô∏è –í–≤–µ–¥–∏—Ç–µ –Ω–µ–ø—É—Å—Ç–æ–π –∑–∞–ø—Ä–æ—Å –¥–ª—è –ø–æ–∏—Å–∫–∞.")
        return
    ctx = get_context()
    users = await ctx.db.search_users(query)
    if not users:
        await message.answer("üì≠ <b>–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ –ø–æ –∑–∞–¥–∞–Ω–Ω–æ–º—É –∑–∞–ø—Ä–æ—Å—É –Ω–µ –Ω–∞–π–¥–µ–Ω—ã.</b>")
        await state.set_state(AdminStates.USER_SYSTEM_MENU)
        return
    user = users[0]
    name_parts = [user.get("first_name") or "", user.get("last_name") or ""]
    full_name = " ".join(p for p in name_parts if p).strip() or "–Ω–µ —É–∫–∞–∑–∞–Ω–æ"
    username_text = f"@{user['username']}" if user.get("username") else "–Ω–µ —É–∫–∞–∑–∞–Ω–æ"
    group_text = user.get("group_code") or "–ù–µ—Ç"
    blocked_text = "–î–∞" if user.get("is_blocked") else "–ù–µ—Ç"
    admin_text = "–î–∞" if user.get("is_admin") else "–ù–µ—Ç"
    lines = [
        "üë§ <b>–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ</b>",
        f"–ò–º—è: <b>{full_name}</b>",
        f"Username: {username_text}",
        f"ID: <code>{user['tg_id']}</code>",
        f"–ì—Ä—É–ø–ø–∞: <b>{group_text}</b>",
        f"–ó–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–ª –±–æ—Ç–∞: <b>{blocked_text}</b>",
        f"–ê–∫—Ç–∏–≤–Ω—ã–π –∞–¥–º–∏–Ω: <b>{admin_text}</b>",
    ]
    if len(users) > 1:
        lines.append("")
        lines.append(f"–ü–æ–∫–∞–∑–∞–Ω –ø–µ—Ä–≤—ã–π –∏–∑ <b>{len(users)}</b> –Ω–∞–π–¥–µ–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π.")
    await message.answer("\n".join(lines))
    await state.set_state(AdminStates.USER_SYSTEM_MENU)


@router.message(AdminStates.USER_SYSTEM_MENU, F.text == "üßë‚Äçüíª –°–µ—Å—Å–∏–∏ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–≤")
async def admin_sessions_view(message: Message, state: FSMContext) -> None:
    session = await _ensure_admin_session_message(message, state, min_level=3)
    if not session:
        return
    ctx = get_context()
    sessions = await ctx.db.get_active_admin_sessions_with_users()
    text = _format_admin_sessions_text(sessions)
    markup = admin_sessions_keyboard(sessions)
    await message.answer(text, reply_markup=markup)


@router.message(AdminStates.MAIN, F.text == "üìÖ –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ–º")
async def admin_schedule_menu(message: Message, state: FSMContext) -> None:
    session = await _ensure_admin_session_message(message, state, min_level=2)
    if not session:
        return
    await state.set_state(AdminStates.SCHEDULE_MENU)
    await message.answer(
        "üìÖ <b>–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ–º</b>\n\n–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:",
        reply_markup=admin_schedule_keyboard(),
    )


@router.message(AdminStates.SCHEDULE_MENU, F.text == "‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –≤ –∞–¥–º–∏–Ω-–º–µ–Ω—é")
async def admin_schedule_back(message: Message, state: FSMContext) -> None:
    session = await _ensure_admin_session_message(message, state, min_level=2)
    if not session:
        return
    level = session.get("level", 1)
    await state.set_state(AdminStates.MAIN)
    await message.answer(
        "üîô –í—ã –≤–µ—Ä–Ω—É–ª–∏—Å—å –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª–∏.",
        reply_markup=admin_main_keyboard(level),
    )


@router.message(AdminStates.SCHEDULE_MENU, F.text == "üìã –ü—Ä–æ—Å–º–æ—Ç—Ä–µ—Ç—å –∞–∫—Ç–∏–≤–Ω—ã–µ –ø–æ–¥–ø–∏—Å–∫–∏")
async def admin_schedule_show_subscriptions(message: Message, state: FSMContext) -> None:
    session = await _ensure_admin_session_message(message, state, min_level=2)
    if not session:
        return
    ctx = get_context()
    url_map = getattr(ctx.schedule_service, "url_map", {}) or {}
    if not url_map:
        await message.answer("üì≠ –ê–∫—Ç–∏–≤–Ω—ã—Ö –ø–æ–¥–ø–∏—Å–æ–∫ –Ω–∞ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–µ—Ç.")
        return
    lines = ["üìã <b>–ê–∫—Ç–∏–≤–Ω—ã–µ –ø–æ–¥–ø–∏—Å–∫–∏ –Ω–∞ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ</b>", ""]
    for group, url in sorted(url_map.items()):
        lines.append(f"<b>{escape(group)}</b>: <code>{escape(url)}</code>")
    await message.answer("\n".join(lines))


@router.message(AdminStates.SCHEDULE_MENU, F.text == "üóë –£–¥–∞–ª–∏—Ç—å —Å—Ç–∞—Ä—ã–µ —Ñ–∞–π–ª—ã")
async def admin_schedule_cleanup_files(message: Message, state: FSMContext) -> None:
    session = await _ensure_admin_session_message(message, state, min_level=2)
    if not session:
        return
    ctx = get_context()
    schedule_service = ctx.schedule_service
    schedule_dir = getattr(schedule_service, "schedule_dir", None)
    if schedule_dir is None:
        await message.answer("‚ö†Ô∏è –î–∏—Ä–µ–∫—Ç–æ—Ä–∏—è —Å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ–º –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.")
        return
    now_ts = dt.datetime.now().timestamp()
    threshold = now_ts - 10 * 24 * 60 * 60
    deleted = 0
    for path in Path(schedule_dir).glob("*.json"):
        try:
            stat = path.stat()
        except OSError:
            continue
        if stat.st_mtime < threshold:
            try:
                path.unlink()
                deleted += 1
            except OSError:
                continue
    if deleted == 0:
        await message.answer("–°—Ç–∞—Ä—ã—Ö —Ñ–∞–π–ª–æ–≤ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.")
    else:
        await message.answer(f"–£–¥–∞–ª–µ–Ω–æ —Å—Ç–∞—Ä—ã—Ö —Ñ–∞–π–ª–æ–≤ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è: <b>{deleted}</b>.")


@router.message(AdminStates.SCHEDULE_MENU, F.text == "üîÑ –ü–µ—Ä–µ–ø–∞—Ä—Å–∏—Ç—å —Ç–µ–∫—É—â–µ–µ")
async def admin_schedule_reparse_current(message: Message, state: FSMContext) -> None:
    session = await _ensure_admin_session_message(message, state, min_level=2)
    if not session:
        return
    ctx = get_context()
    schedule_service = ctx.schedule_service
    url_map = getattr(schedule_service, "url_map", {}) or {}
    if not url_map:
        await message.answer("üì≠ –ù–µ—Ç –≥—Ä—É–ø–ø —Å –Ω–∞—Å—Ç—Ä–æ–µ–Ω–Ω—ã–º–∏ URL —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è.")
        return
    await message.answer("üîÑ –ù–∞—á–∏–Ω–∞—é –ø–µ—Ä–µ–ø–∞—Ä—Å–∏–≤–∞–Ω–∏–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è –¥–ª—è –≤—Å–µ—Ö –≥—Ä—É–ø–ø. –≠—Ç–æ –º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å –≤—Ä–µ–º—è.")
    today = dt.date.today()
    monday, sunday = week_bounds_mon_sun(today)
    success = 0
    errors = 0
    for group_code, url in url_map.items():
        if not url:
            continue
        try:
            schedule = await asyncio.to_thread(parse_schedule, url)
            if schedule:
                schedule_service._save_schedule(group_code, today, schedule)
                success += 1
            else:
                errors += 1
        except Exception:
            errors += 1
    if success == 0:
        await message.answer(
            f"‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–∏ –¥–ª—è –æ–¥–Ω–æ–π –≥—Ä—É–ø–ø—ã –∑–∞ –ø–µ—Ä–∏–æ–¥ {monday.strftime('%d.%m.%Y')}‚Äì{sunday.strftime('%d.%m.%Y')}."
        )
    else:
        await message.answer(
            f"‚úÖ –ü–µ—Ä–µ–ø–∞—Ä—Å–∏–≤–∞–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ.\n"
            f"–£—Å–ø–µ—à–Ω–æ –≥—Ä—É–ø–ø: <b>{success}</b>\n"
            f"–û—à–∏–±–æ–∫: <b>{errors}</b>"
        )


@router.message(AdminStates.MAIN, F.text == "üìä –õ–æ–≥–∏ –∏ —Å—Ç–∞—Ç—É—Å")
async def admin_logs_menu(message: Message, state: FSMContext) -> None:
    session = await _ensure_admin_session_message(message, state)
    if not session:
        return
    await state.set_state(AdminStates.LOGS_MENU)
    await message.answer(
        "üìä <b>–õ–æ–≥–∏ –∏ —Å–∏—Å—Ç–µ–º–Ω—ã–π —Å—Ç–∞—Ç—É—Å</b>\n\n–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:",
        reply_markup=admin_logs_keyboard(),
    )


@router.message(AdminStates.LOGS_MENU, F.text == "‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –≤ –∞–¥–º–∏–Ω-–º–µ–Ω—é")
async def admin_logs_back(message: Message, state: FSMContext) -> None:
    session = await _ensure_admin_session_message(message, state)
    if not session:
        return
    level = session.get("level", 1)
    await state.set_state(AdminStates.MAIN)
    await message.answer(
        "üîô –í—ã –≤–µ—Ä–Ω—É–ª–∏—Å—å –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª–∏.",
        reply_markup=admin_main_keyboard(level),
    )


@router.message(AdminStates.LOGS_MENU, F.text == "‚è±Ô∏è –ü–æ–∫–∞–∑–∞—Ç—å uptime")
async def admin_show_uptime(message: Message, state: FSMContext) -> None:
    session = await _ensure_admin_session_message(message, state)
    if not session:
        return
    now = dt.datetime.utcnow()
    delta = now - BOT_START_TIME
    total_seconds = int(delta.total_seconds())
    days = total_seconds // 86400
    rem = total_seconds % 86400
    hours = rem // 3600
    rem %= 3600
    minutes = rem // 60
    seconds = rem % 60
    parts = []
    if days:
        parts.append(f"{days} –¥")
    if hours or days:
        parts.append(f"{hours} —á")
    if minutes or hours or days:
        parts.append(f"{minutes} –º–∏–Ω")
    parts.append(f"{seconds} —Å")
    text = "‚è±Ô∏è <b>–í—Ä–µ–º—è —Ä–∞–±–æ—Ç—ã –±–æ—Ç–∞</b>\n\n" + " ".join(parts)
    await message.answer(text)


@router.message(AdminStates.LOGS_MENU, F.text == "üìú –ü–æ–∫–∞–∑–∞—Ç—å –ø–æ—Å–ª–µ–¥–Ω–∏–µ N —Å—Ç—Ä–æ–∫ –ª–æ–≥–æ–≤")
async def admin_logs_ask_lines(message: Message, state: FSMContext) -> None:
    session = await _ensure_admin_session_message(message, state)
    if not session:
        return
    await state.set_state(AdminStates.LOGS_WAIT_LINES)
    await message.answer(
        "–í–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ N ‚Äî —Å–∫–æ–ª—å–∫–æ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö —Å—Ç—Ä–æ–∫ –∏–∑ —Å–∏—Å—Ç–µ–º–Ω–æ–≥–æ –ª–æ–≥–∞ –ø–æ–∫–∞–∑–∞—Ç—å.\n–ù–∞–ø—Ä–∏–º–µ—Ä: <code>100</code>"
    )


@router.message(AdminStates.LOGS_WAIT_LINES)
async def admin_logs_show_lines(message: Message, state: FSMContext) -> None:
    session = await _ensure_admin_session_message(message, state)
    if not session:
        return
    text_raw = (message.text or "").strip()
    if not text_raw.isdigit():
        await message.answer("–í–≤–µ–¥–∏—Ç–µ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–µ —á–∏—Å–ª–æ.")
        return
    n = int(text_raw)
    if n <= 0:
        await message.answer("–ß–∏—Å–ª–æ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –±–æ–ª—å—à–µ –Ω—É–ª—è.")
        return
    if n > 2000:
        n = 2000
    if not LOG_PATH.exists():
        await state.set_state(AdminStates.LOGS_MENU)
        await message.answer(
            "–§–∞–π–ª —Å–∏—Å—Ç–µ–º–Ω–æ–≥–æ –ª–æ–≥–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω.",
            reply_markup=admin_logs_keyboard(),
        )
        return
    with LOG_PATH.open(encoding="utf-8", errors="ignore") as f:
        lines = f.readlines()
    tail = "".join(lines[-n:])
    payload = escape(tail)
    await message.answer(
        f"üìú <b>–ü–æ—Å–ª–µ–¥–Ω–∏–µ {n} —Å—Ç—Ä–æ–∫ —Å–∏—Å—Ç–µ–º–Ω–æ–≥–æ –ª–æ–≥–∞</b>:\n<pre>{payload}</pre>"
    )
    await state.set_state(AdminStates.LOGS_MENU)
    await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –¥–∞–ª—å–Ω–µ–π—à–µ–µ –¥–µ–π—Å—Ç–≤–∏–µ:", reply_markup=admin_logs_keyboard())


@router.message(AdminStates.LOGS_MENU, F.text == "üß† –ü–∞–º—è—Ç—å –∏ CPU")
async def admin_logs_resources(message: Message, state: FSMContext) -> None:
    session = await _ensure_admin_session_message(message, state)
    if not session:
        return
    cpu_percents = psutil.cpu_percent(percpu=True)
    cpu_lines = []
    for idx, val in enumerate(cpu_percents, 1):
        cpu_lines.append(f"–Ø–¥—Ä–æ {idx}: {val:.1f}%")
    vm = psutil.virtual_memory()
    swap = psutil.swap_memory()
    proc = psutil.Process()
    pmem = proc.memory_info()
    mb = 1024 * 1024
    ram_lines = [
        f"–í—Å–µ–≥–æ: {vm.total / mb:.1f} –ú–ë",
        f"–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–æ: {vm.used / mb:.1f} –ú–ë ({vm.percent:.1f}%)",
        f"–°–≤–æ–±–æ–¥–Ω–æ: {vm.available / mb:.1f} –ú–ë",
        f"–ü—Ä–æ—Ü–µ—Å—Å –±–æ—Ç–∞ (RSS): {pmem.rss / mb:.1f} –ú–ë",
    ]
    swap_lines = [
        f"–í—Å–µ–≥–æ: {swap.total / mb:.1f} –ú–ë",
        f"–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–æ: {swap.used / mb:.1f} –ú–ë ({swap.percent:.1f}%)",
        f"–°–≤–æ–±–æ–¥–Ω–æ: {(swap.total - swap.used) / mb:.1f} –ú–ë",
    ]
    config_path = BASE_DIR / "config"
    disk = psutil.disk_usage(str(config_path))
    gb = 1024 * 1024 * 1024
    disk_lines = [
        f"–í—Å–µ–≥–æ: {disk.total / gb:.2f} –ì–ë",
        f"–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–æ: {disk.used / gb:.2f} –ì–ë ({disk.percent:.1f}%)",
        f"–°–≤–æ–±–æ–¥–Ω–æ: {disk.free / gb:.2f} –ì–ë",
    ]
    text = (
        "üß† <b>–ü–∞–º—è—Ç—å –∏ CPU</b>\n\n"
        "CPU –ø–æ —è–¥—Ä–∞–º:\n<pre>\n" + "\n".join(cpu_lines) + "\n</pre>\n\n"
        "RAM:\n<pre>\n" + "\n".join(ram_lines) + "\n</pre>\n\n"
        "Swap:\n<pre>\n" + "\n".join(swap_lines) + "\n</pre>\n\n"
        f"–î–∏—Å–∫ –¥–ª—è config/ ({config_path}):\n<pre>\n" + "\n".join(disk_lines) + "\n</pre>"
    )
    await message.answer(text)


@router.message(AdminStates.LOGS_MENU, F.text == "üì• –°–∫–∞—á–∞—Ç—å –≤–µ—Å—å –ª–æ–≥")
async def admin_logs_download(message: Message, state: FSMContext) -> None:
    session = await _ensure_admin_session_message(message, state)
    if not session:
        return
    lines_out: list[str] = []
    if LOG_PATH.exists():
        with LOG_PATH.open(encoding="utf-8", errors="ignore") as f:
            system_lines = f.read().splitlines()
        if system_lines:
            lines_out.append("===== SYSTEM LOG =====")
            lines_out.extend(system_lines)
    entries: list[dict] = []
    if USER_ERRORS_LOG_PATH.exists():
        with USER_ERRORS_LOG_PATH.open(encoding="utf-8", errors="ignore") as f:
            for line in f:
                line = line.strip()
                if not line:
                    continue
                try:
                    data = json.loads(line)
                except Exception:
                    continue
                if isinstance(data, dict):
                    entries.append(data)
    if entries:
        if lines_out:
            lines_out.append("")
            lines_out.append("")
        lines_out.append("===== USER ERRORS =====")
        for item in entries:
            ts = item.get("timestamp") or ""
            user_id = item.get("user_id") or item.get("tg_id")
            username = item.get("username") or ""
            text_val = item.get("text")
            data_val = item.get("data")
            action = item.get("action")
            if not action:
                if data_val:
                    action = f"callback: {data_val}"
                elif text_val:
                    action = f"message: {text_val}"
                else:
                    action = ""
            err = item.get("error") or ""
            tb = item.get("traceback") or ""
            lines_out.append(f"[{ts}] user_id={user_id} username={username}")
            if action:
                lines_out.append(f"action: {action}")
            if err:
                lines_out.append(f"error: {err}")
            if tb:
                lines_out.append(tb)
            lines_out.append("")
    if not lines_out:
        await message.answer("–õ–æ–≥–∏ –ø–æ–∫–∞ –ø—É—Å—Ç—ã.")
        return
    with FULL_LOG_PATH.open("w", encoding="utf-8") as f:
        f.write("\n".join(lines_out))
    file = FSInputFile(str(FULL_LOG_PATH))
    await message.answer_document(file, caption="–ü–æ–ª–Ω—ã–π –ª–æ–≥ –±–æ—Ç–∞ (—Å–∏—Å—Ç–µ–º–Ω—ã–π –∏ –æ—à–∏–±–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π).")


@router.message(AdminStates.LOGS_MENU, F.text == "üßë‚Äçüíª –õ–æ–≥–∏ –æ—à–∏–±–æ–∫ –ª—é–¥–µ–π")
async def admin_logs_user_errors_ask(message: Message, state: FSMContext) -> None:
    session = await _ensure_admin_session_message(message, state)
    if not session:
        return
    await state.set_state(AdminStates.LOGS_WAIT_USER_ERRORS_LINES)
    await message.answer(
        "–í–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ N ‚Äî —Å–∫–æ–ª—å–∫–æ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö –æ—à–∏–±–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –ø–æ–∫–∞–∑–∞—Ç—å.\n–ù–∞–ø—Ä–∏–º–µ—Ä: <code>50</code>"
    )


@router.message(AdminStates.LOGS_WAIT_USER_ERRORS_LINES)
async def admin_logs_user_errors_show(message: Message, state: FSMContext) -> None:
    session = await _ensure_admin_session_message(message, state)
    if not session:
        return
    text_raw = (message.text or "").strip()
    if not text_raw.isdigit():
        await message.answer("–í–≤–µ–¥–∏—Ç–µ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–µ —á–∏—Å–ª–æ.")
        return
    n = int(text_raw)
    if n <= 0:
        await message.answer("–ß–∏—Å–ª–æ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –±–æ–ª—å—à–µ –Ω—É–ª—è.")
        return
    if n > 1000:
        n = 1000
    if not USER_ERRORS_LOG_PATH.exists():
        await state.set_state(AdminStates.LOGS_MENU)
        await message.answer(
            "–§–∞–π–ª –ª–æ–≥–æ–≤ –æ—à–∏–±–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –Ω–µ –Ω–∞–π–¥–µ–Ω.",
            reply_markup=admin_logs_keyboard(),
        )
        return
    entries: list[dict] = []
    with USER_ERRORS_LOG_PATH.open(encoding="utf-8", errors="ignore") as f:
        for line in f:
            line = line.strip()
            if not line:
                continue
            try:
                data = json.loads(line)
            except Exception:
                continue
            if isinstance(data, dict):
                entries.append(data)
    tail = entries[-n:]
    if not tail:
        await state.set_state(AdminStates.LOGS_MENU)
        await message.answer(
            "–ó–∞–ø–∏—Å–µ–π –æ–± –æ—à–∏–±–∫–∞—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.",
            reply_markup=admin_logs_keyboard(),
        )
        return
    lines_out: list[str] = ["üßë‚Äçüíª <b>–ü–æ—Å–ª–µ–¥–Ω–∏–µ –æ—à–∏–±–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π</b>", ""]
    for item in tail:
        ts = item.get("timestamp") or ""
        user_id = item.get("user_id") or item.get("tg_id")
        username = item.get("username")
        text_val = item.get("text")
        data_val = item.get("data")
        action = item.get("action")
        if not action:
            if data_val:
                action = f"callback: {data_val}"
            elif text_val:
                action = f"message: {text_val}"
            else:
                action = ""
        err = item.get("error") or ""
        tb = item.get("traceback") or ""
        username_text = f"@{username}" if username else "-"
        lines_out.append(
            f"‚è± {escape(str(ts))}\n"
            f"üë§ ID: <code>{user_id}</code>, {escape(username_text)}\n"
            f"‚öô –î–µ–π—Å—Ç–≤–∏–µ: <code>{escape(str(action))}</code>\n"
            f"‚ùå –û—à–∏–±–∫–∞: <code>{escape(str(err))}</code>\n"
            f"üßµ Traceback:\n<pre>{escape(str(tb))}</pre>\n"
        )
    await message.answer("\n".join(lines_out))
    await state.set_state(AdminStates.LOGS_MENU)
    await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –¥–∞–ª—å–Ω–µ–π—à–µ–µ –¥–µ–π—Å—Ç–≤–∏–µ:", reply_markup=admin_logs_keyboard())


@router.message(AdminStates.MAIN, F.text == "üì¢ –†–∞—Å—Å—ã–ª–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π")
async def admin_broadcast_start(message: Message, state: FSMContext) -> None:
    session = await _ensure_admin_session_message(message, state, min_level=2)
    if not session:
        return
    await state.set_state(AdminStates.BROADCAST_WAIT_MESSAGE)
    await message.answer(
        "üì¢ <b>–†–∞—Å—Å—ã–ª–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π</b>\n\n"
        "–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ –Ω—É–∂–Ω–æ —Ä–∞–∑–æ—Å–ª–∞—Ç—å –≤—Å–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º.\n"
        "–ú–æ–∂–Ω–æ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Ç–µ–∫—Å—Ç, —Ñ–æ—Ç–æ, —Ñ–∞–π–ª –∏ —Ç.–ø.\n\n"
        "–î–ª—è –æ—Ç–º–µ–Ω—ã —Ä–∞—Å—Å—ã–ª–∫–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ.",
        reply_markup=broadcast_cancel_inline_keyboard(),
    )


@router.message(AdminStates.BROADCAST_WAIT_MESSAGE)
async def admin_broadcast_process(message: Message, state: FSMContext) -> None:
    session = await _ensure_admin_session_message(message, state, min_level=2)
    if not session:
        return
    ctx = get_context()
    users = await ctx.db.get_all_users_for_broadcast()
    blocklist = _load_broadcast_blocklist()
    blocked_ids = set(blocklist.get("ids", []))
    blocked_usernames = set(blocklist.get("usernames", []))
    sent = 0
    errors = 0
    for u in users:
        tg_id = u.get("tg_id")
        if not tg_id:
            continue
        if tg_id == message.chat.id:
            continue
        username = u.get("username")
        if tg_id in blocked_ids:
            continue
        if username and username.lower() in blocked_usernames:
            continue
        if u.get("is_blocked"):
            continue
        banned = await ctx.db.is_user_banned(tg_id, username)
        if banned:
            continue
        try:
            await message.bot.copy_message(
                chat_id=tg_id,
                from_chat_id=message.chat.id,
                message_id=message.message_id,
            )
            sent += 1
        except Exception:
            errors += 1
            await ctx.db.set_user_blocked(tg_id, True)
    level = session.get("level", 1)
    await state.set_state(AdminStates.MAIN)
    await message.answer(
        f"üì¢ –†–∞—Å—Å—ã–ª–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞.\n\n"
        f"–£—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ: <b>{sent}</b>\n"
        f"–û—à–∏–±–æ–∫ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ: <b>{errors}</b>",
        reply_markup=admin_main_keyboard(level),
    )


@router.message(AdminStates.MAIN, F.text == "üö´ –ë–∞–Ω / –†–∞–∑–±–∞–Ω")
async def admin_ban_menu(message: Message, state: FSMContext) -> None:
    session = await _ensure_admin_session_message(message, state, min_level=2)
    if not session:
        return
    await state.set_state(AdminStates.BAN_MENU)
    await message.answer(
        "üö´ <b>–ë–∞–Ω / –†–∞–∑–±–∞–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π</b>\n\n–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:",
        reply_markup=admin_ban_keyboard(),
    )


@router.message(AdminStates.BAN_MENU, F.text == "‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –≤ –∞–¥–º–∏–Ω-–º–µ–Ω—é")
async def admin_ban_back(message: Message, state: FSMContext) -> None:
    session = await _ensure_admin_session_message(message, state, min_level=2)
    if not session:
        return
    level = session.get("level", 1)
    await state.set_state(AdminStates.MAIN)
    await message.answer(
        "üîô –í—ã –≤–µ—Ä–Ω—É–ª–∏—Å—å –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª–∏.",
        reply_markup=admin_main_keyboard(level),
    )


@router.message(AdminStates.BAN_MENU, F.text == "üìã –°–ø–∏—Å–æ–∫ –∑–∞–±–∞–Ω–µ–Ω–Ω—ã—Ö")
async def admin_ban_list(message: Message, state: FSMContext) -> None:
    session = await _ensure_admin_session_message(message, state, min_level=2)
    if not session:
        return
    ctx = get_context()
    banned = await ctx.db.get_banned_users()
    if not banned:
        await message.answer("üì≠ –°–ø–∏—Å–æ–∫ –∑–∞–±–∞–Ω–µ–Ω–Ω—ã—Ö –ø—É—Å—Ç.")
        return
    lines = ["üö´ <b>–°–ø–∏—Å–æ–∫ –∑–∞–±–∞–Ω–µ–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π</b>", ""]
    for item in banned:
        tg_id = item.get("tg_id")
        username = item.get("username")
        reason = item.get("reason") or "-"
        if username:
            ident = f"@{username}"
            if tg_id:
                ident = f"{tg_id} / {ident}"
        else:
            ident = str(tg_id) if tg_id else "–Ω–µ —É–∫–∞–∑–∞–Ω"
        lines.append(f"{escape(ident)}: {escape(str(reason))}")
    await message.answer("\n".join(lines))


@router.message(AdminStates.BAN_MENU, F.text == "üö´ –ë–∞–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è")
async def admin_ban_start(message: Message, state: FSMContext) -> None:
    session = await _ensure_admin_session_message(message, state, min_level=2)
    if not session:
        return
    await state.set_state(AdminStates.BAN_WAIT_USER)
    await message.answer(
        "–û—Ç–ø—Ä–∞–≤—å—Ç–µ ID –∏–ª–∏ @username –∏ –ø—Ä–∏—á–∏–Ω—É –±–∞–Ω–∞ –≤ –æ–¥–Ω–æ–º —Å–æ–æ–±—â–µ–Ω–∏–∏.\n"
        "–ü—Ä–∏–º–µ—Ä: <code>123456 –°–ø–∞–º</code> –∏–ª–∏ <code>@user –û—Å–∫–æ—Ä–±–ª–µ–Ω–∏—è</code>."
    )


@router.message(AdminStates.BAN_WAIT_USER)
async def admin_ban_process(message: Message, state: FSMContext) -> None:
    session = await _ensure_admin_session_message(message, state, min_level=2)
    if not session:
        return
    text_raw = (message.text or "").strip()
    if not text_raw:
        await message.answer("–í–≤–µ–¥–∏—Ç–µ ID –∏–ª–∏ username –∏ –ø—Ä–∏—á–∏–Ω—É.")
        return
    parts = text_raw.split(maxsplit=1)
    ident = parts[0]
    reason = parts[1].strip() if len(parts) > 1 else "–ë–µ–∑ –ø—Ä–∏—á–∏–Ω—ã"
    ctx = get_context()
    tg_id: int | None
    username: str | None
    if ident.lstrip("@").isdigit():
        tg_id = int(ident.lstrip("@"))
        username = None
        user = await ctx.db.get_user(tg_id)
        if user and user.get("username"):
            username = user["username"]
    else:
        username = ident.lstrip("@")
        user_list = await ctx.db.search_users(username)
        if user_list:
            tg_id = user_list[0].get("tg_id")
            username = user_list[0].get("username") or username
        else:
            tg_id = None
    await ctx.db.ban_user(tg_id, username, reason)
    await state.set_state(AdminStates.BAN_MENU)
    await message.answer("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –¥–æ–±–∞–≤–ª–µ–Ω –≤ –±–∞–Ω-–ª–∏—Å—Ç.", reply_markup=admin_ban_keyboard())


@router.message(AdminStates.BAN_MENU, F.text == "‚úÖ –†–∞–∑–±–∞–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è")
async def admin_unban_start(message: Message, state: FSMContext) -> None:
    session = await _ensure_admin_session_message(message, state, min_level=2)
    if not session:
        return
    await state.set_state(AdminStates.UNBAN_WAIT_USER)
    await message.answer(
        "–û—Ç–ø—Ä–∞–≤—å—Ç–µ ID –∏–ª–∏ @username –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, –∫–æ—Ç–æ—Ä–æ–≥–æ –Ω—É–∂–Ω–æ —Ä–∞–∑–±–∞–Ω–∏—Ç—å."
    )


@router.message(AdminStates.UNBAN_WAIT_USER)
async def admin_unban_process(message: Message, state: FSMContext) -> None:
    session = await _ensure_admin_session_message(message, state, min_level=2)
    if not session:
        return
    text_raw = (message.text or "").strip()
    if not text_raw:
        await message.answer("–í–≤–µ–¥–∏—Ç–µ ID –∏–ª–∏ username.")
        return
    ident = text_raw
    ctx = get_context()
    affected = 0
    if ident.lstrip("@").isdigit():
        tg_id = int(ident.lstrip("@"))
        affected = await ctx.db.unban_by_tg_id(tg_id)
    else:
        username = ident.lstrip("@")
        affected = await ctx.db.unban_by_username(username)
    await state.set_state(AdminStates.BAN_MENU)
    if affected == 0:
        await message.answer("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ —Å–ø–∏—Å–∫–µ –±–∞–Ω–æ–≤.", reply_markup=admin_ban_keyboard())
    else:
        await message.answer("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Ä–∞–∑–±–∞–Ω–µ–Ω.", reply_markup=admin_ban_keyboard())


@router.message(AdminStates.MAIN, F.text == "‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –∫–∞—Ç–µ–≥–æ—Ä–∏–π")
async def admin_categories_menu(message: Message, state: FSMContext) -> None:
    session = await _ensure_admin_session_message(message, state, min_level=2)
    if not session:
        return
    cfg = _load_categories_config()
    await state.set_state(AdminStates.CATEGORIES_SELECT)
    lines = ["‚öôÔ∏è <b>–ù–∞—Å—Ç—Ä–æ–π–∫–∞ –∫–∞—Ç–µ–≥–æ—Ä–∏–π</b>", ""]
    for name, info in cfg.items():
        enabled = bool(info.get("enabled", True))
        status = "–≤–∫–ª—é—á–µ–Ω–∞" if enabled else "–≤—ã–∫–ª—é—á–µ–Ω–∞"
        lines.append(f"{name}: <b>{status}</b>")
    lines.append("")
    lines.append("–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—é –¥–ª—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∏.")
    kb = _categories_list_keyboard(list(cfg.keys()))
    await message.answer("\n".join(lines), reply_markup=kb)


@router.message(AdminStates.CATEGORIES_SELECT)
async def admin_categories_select(message: Message, state: FSMContext) -> None:
    session = await _ensure_admin_session_message(message, state, min_level=2)
    if not session:
        return
    cfg = _load_categories_config()
    text = message.text or ""
    if text == "‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –≤ –∞–¥–º–∏–Ω-–º–µ–Ω—é":
        level = session.get("level", 1)
        await state.set_state(AdminStates.MAIN)
        await message.answer(
            "üîô –í—ã –≤–µ—Ä–Ω—É–ª–∏—Å—å –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª–∏.",
            reply_markup=admin_main_keyboard(level),
        )
        return
    if text not in cfg:
        kb = _categories_list_keyboard(list(cfg.keys()))
        await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—é –∏–∑ —Å–ø–∏—Å–∫–∞ –Ω–∏–∂–µ.", reply_markup=kb)
        return
    await state.update_data(current_category=text)
    info = cfg.get(text, {})
    enabled = bool(info.get("enabled", True))
    disabled_text = info.get("disabled_text") or DEFAULT_CATEGORY_DISABLED_TEXT
    status = "–≤–∫–ª—é—á–µ–Ω–∞" if enabled else "–≤—ã–∫–ª—é—á–µ–Ω–∞"
    lines = [
        f"–ö–∞—Ç–µ–≥–æ—Ä–∏—è: <b>{text}</b>",
        f"–°—Ç–∞—Ç—É—Å: <b>{status}</b>",
        "",
        "–¢–µ–∫—Å—Ç –ø—Ä–∏ –æ—Ç–∫–ª—é—á–µ–Ω–∏–∏:",
        disabled_text,
    ]
    kb = _category_menu_keyboard(enabled)
    await state.set_state(AdminStates.CATEGORIES_CATEGORY_MENU)
    await message.answer("\n".join(lines), reply_markup=kb)


@router.message(AdminStates.CATEGORIES_CATEGORY_MENU)
async def admin_categories_category_menu(message: Message, state: FSMContext) -> None:
    session = await _ensure_admin_session_message(message, state, min_level=2)
    if not session:
        return
    data = await state.get_data()
    category = data.get("current_category")
    if not category:
        cfg = _load_categories_config()
        kb = _categories_list_keyboard(list(cfg.keys()))
        await state.set_state(AdminStates.CATEGORIES_SELECT)
        await message.answer("–°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—é.", reply_markup=kb)
        return
    cfg = _load_categories_config()
    info = cfg.get(category, {"enabled": True, "disabled_text": DEFAULT_CATEGORY_DISABLED_TEXT})
    enabled = bool(info.get("enabled", True))
    text = message.text or ""
    if text == "‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –≤ –∞–¥–º–∏–Ω-–º–µ–Ω—é":
        level = session.get("level", 1)
        await state.set_state(AdminStates.MAIN)
        await message.answer(
            "üîô –í—ã –≤–µ—Ä–Ω—É–ª–∏—Å—å –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª–∏.",
            reply_markup=admin_main_keyboard(level),
        )
        return
    if text == "üîô –í—ã–±—Ä–∞—Ç—å –¥—Ä—É–≥—É—é –∫–∞—Ç–µ–≥–æ—Ä–∏—é":
        cfg = _load_categories_config()
        kb = _categories_list_keyboard(list(cfg.keys()))
        await state.set_state(AdminStates.CATEGORIES_SELECT)
        await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –¥—Ä—É–≥—É—é –∫–∞—Ç–µ–≥–æ—Ä–∏—é.", reply_markup=kb)
        return
    if text in {"‚úÖ –í–∫–ª—é—á–∏—Ç—å", "‚õî –í—ã–∫–ª—é—á–∏—Ç—å"}:
        new_enabled = text == "‚úÖ –í–∫–ª—é—á–∏—Ç—å"
        info["enabled"] = new_enabled
        cfg[category] = info
        _save_categories_config(cfg)
        enabled = new_enabled
        status = "–≤–∫–ª—é—á–µ–Ω–∞" if enabled else "–≤—ã–∫–ª—é—á–µ–Ω–∞"
        disabled_text = info.get("disabled_text") or DEFAULT_CATEGORY_DISABLED_TEXT
        lines = [
            f"–ö–∞—Ç–µ–≥–æ—Ä–∏—è: <b>{category}</b>",
            f"–°—Ç–∞—Ç—É—Å: <b>{status}</b>",
            "",
            "–¢–µ–∫—Å—Ç –ø—Ä–∏ –æ—Ç–∫–ª—é—á–µ–Ω–∏–∏:",
            disabled_text,
        ]
        kb = _category_menu_keyboard(enabled)
        await message.answer("–°—Ç–∞—Ç—É—Å –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –æ–±–Ω–æ–≤–ª—ë–Ω.", reply_markup=kb)
        await message.answer("\n".join(lines), reply_markup=kb)
        return
    if text == "‚úèÔ∏è –¢–µ–∫—Å—Ç –ø—Ä–∏ –æ—Ç–∫–ª—é—á–µ–Ω–∏–∏":
        await state.set_state(AdminStates.CATEGORY_EDIT_TEXT)
        await message.answer(
            "–û—Ç–ø—Ä–∞–≤—å—Ç–µ –Ω–æ–≤—ã–π —Ç–µ–∫—Å—Ç, –∫–æ—Ç–æ—Ä—ã–π –±—É–¥–µ—Ç –ø–æ–∫–∞–∑—ã–≤–∞—Ç—å—Å—è –ø—Ä–∏ –æ—Ç–∫–ª—é—á—ë–Ω–Ω–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏.\n"
            "–î–ª—è —Å–±—Ä–æ—Å–∞ –Ω–∞ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Å–ª–æ–≤–æ <code>—Å–±—Ä–æ—Å</code>."
        )
        return
    kb = _category_menu_keyboard(enabled)
    await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫–∏ –º–µ–Ω—é.", reply_markup=kb)


@router.message(AdminStates.CATEGORY_EDIT_TEXT)
async def admin_category_edit_text(message: Message, state: FSMContext) -> None:
    session = await _ensure_admin_session_message(message, state, min_level=2)
    if not session:
        return
    data = await state.get_data()
    category = data.get("current_category")
    if not category:
        cfg = _load_categories_config()
        kb = _categories_list_keyboard(list(cfg.keys()))
        await state.set_state(AdminStates.CATEGORIES_SELECT)
        await message.answer("–°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—é.", reply_markup=kb)
        return
    cfg = _load_categories_config()
    info = cfg.get(category, {"enabled": True, "disabled_text": DEFAULT_CATEGORY_DISABLED_TEXT})
    text_raw = (message.text or "").strip()
    if text_raw.lower() == "—Å–±—Ä–æ—Å":
        info["disabled_text"] = DEFAULT_CATEGORY_DISABLED_TEXT
    else:
        if not text_raw:
            await message.answer("–¢–µ–∫—Å—Ç –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –Ω–æ–≤—ã–π —Ç–µ–∫—Å—Ç –∏–ª–∏ —Å–ª–æ–≤–æ ¬´—Å–±—Ä–æ—Å¬ª.")
            return
        info["disabled_text"] = text_raw
    cfg[category] = info
    _save_categories_config(cfg)
    await state.set_state(AdminStates.CATEGORIES_CATEGORY_MENU)
    enabled = bool(info.get("enabled", True))
    status = "–≤–∫–ª—é—á–µ–Ω–∞" if enabled else "–≤—ã–∫–ª—é—á–µ–Ω–∞"
    disabled_text = info.get("disabled_text") or DEFAULT_CATEGORY_DISABLED_TEXT
    lines = [
        f"–ö–∞—Ç–µ–≥–æ—Ä–∏—è: <b>{category}</b>",
        f"–°—Ç–∞—Ç—É—Å: <b>{status}</b>",
        "",
        "–¢–µ–∫—Å—Ç –ø—Ä–∏ –æ—Ç–∫–ª—é—á–µ–Ω–∏–∏:",
        disabled_text,
    ]
    kb = _category_menu_keyboard(enabled)
    await message.answer("–¢–µ–∫—Å—Ç –ø—Ä–∏ –æ—Ç–∫–ª—é—á–µ–Ω–∏–∏ –æ–±–Ω–æ–≤–ª—ë–Ω.", reply_markup=kb)
    await message.answer("\n".join(lines), reply_markup=kb)


@router.message(AdminStates.MAIN, F.text == "‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Ä–∞—Å—Å—ã–ª–∫–∏")
async def admin_mailing_menu(message: Message, state: FSMContext) -> None:
    session = await _ensure_admin_session_message(message, state, min_level=1)
    if not session:
        return
    await state.set_state(AdminStates.MAILING_MENU)
    blocklist = _load_broadcast_blocklist()
    ids = blocklist.get("ids", [])
    usernames = blocklist.get("usernames", [])
    lines = [
        "‚öôÔ∏è <b>–ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Ä–∞—Å—Å—ã–ª–∫–∏</b>",
        "",
        "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ –≤ –±–ª–æ–∫-–ª–∏—Å—Ç–µ –Ω–µ –ø–æ–ª—É—á–∞—é—Ç –º–∞—Å—Å–æ–≤—ã–µ —Ä–∞—Å—Å—ã–ª–∫–∏.",
        "",
        f"ID –≤ –±–ª–æ–∫-–ª–∏—Å—Ç–µ: <b>{len(ids)}</b>",
        f"Usernames –≤ –±–ª–æ–∫-–ª–∏—Å—Ç–µ: <b>{len(usernames)}</b>",
    ]
    await message.answer("\n".join(lines), reply_markup=admin_mailing_keyboard())


@router.message(AdminStates.MAILING_MENU, F.text == "‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –≤ –∞–¥–º–∏–Ω-–º–µ–Ω—é")
async def admin_mailing_back(message: Message, state: FSMContext) -> None:
    session = await _ensure_admin_session_message(message, state, min_level=1)
    if not session:
        return
    level = session.get("level", 1)
    await state.set_state(AdminStates.MAIN)
    await message.answer(
        "üîô –í—ã –≤–µ—Ä–Ω—É–ª–∏—Å—å –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª–∏.",
        reply_markup=admin_main_keyboard(level),
    )


@router.message(AdminStates.MAILING_MENU, F.text == "üìã –ü–æ–∫–∞–∑–∞—Ç—å –∏—Å–∫–ª—é—á–µ–Ω–∏—è")
async def admin_mailing_show_list(message: Message, state: FSMContext) -> None:
    session = await _ensure_admin_session_message(message, state, min_level=1)
    if not session:
        return
    blocklist = _load_broadcast_blocklist()
    ids = blocklist.get("ids", [])
    usernames = blocklist.get("usernames", [])
    lines = [
        "üìã <b>–ò—Å–∫–ª—é—á–µ–Ω–∏—è –∏–∑ —Ä–∞—Å—Å—ã–ª–∫–∏</b>",
        "",
        "ID:",
    ]
    if ids:
        for v in ids:
            lines.append(f"‚Ä¢ <code>{v}</code>")
    else:
        lines.append("‚Ä¢ –Ω–µ—Ç")
    lines.append("")
    lines.append("Usernames:")
    if usernames:
        for u in usernames:
            lines.append(f"‚Ä¢ @{u}")
    else:
        lines.append("‚Ä¢ –Ω–µ—Ç")
    await message.answer("\n".join(lines))


@router.message(AdminStates.MAILING_MENU, F.text == "üö´ –û—Ç–∫–ª—é—á–∏—Ç—å —Ä–∞—Å—Å—ã–ª–∫—É –¥–ª—è ID/@username")
async def admin_mailing_block_start(message: Message, state: FSMContext) -> None:
    session = await _ensure_admin_session_message(message, state, min_level=1)
    if not session:
        return
    await state.set_state(AdminStates.MAILING_BLOCK_WAIT_USER)
    await message.answer(
        "–û—Ç–ø—Ä–∞–≤—å—Ç–µ ID –∏–ª–∏ @username –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, –∫–æ—Ç–æ—Ä–æ–≥–æ –Ω—É–∂–Ω–æ –∏—Å–∫–ª—é—á–∏—Ç—å –∏–∑ —Ä–∞—Å—Å—ã–ª–æ–∫."
    )


@router.message(AdminStates.MAILING_BLOCK_WAIT_USER)
async def admin_mailing_block_process(message: Message, state: FSMContext) -> None:
    session = await _ensure_admin_session_message(message, state, min_level=1)
    if not session:
        return
    text_raw = (message.text or "").strip()
    if not text_raw:
        await message.answer("–í–≤–µ–¥–∏—Ç–µ ID –∏–ª–∏ username.")
        return
    ident = text_raw
    blocklist = _load_broadcast_blocklist()
    ids = set(blocklist.get("ids", []))
    usernames = set(blocklist.get("usernames", []))
    if ident.lstrip("@").isdigit():
        ids.add(int(ident.lstrip("@")))
    else:
        usernames.add(ident.lstrip("@").lower())
    _save_broadcast_blocklist({"ids": list(ids), "usernames": list(usernames)})
    await state.set_state(AdminStates.MAILING_MENU)
    await message.answer("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –¥–æ–±–∞–≤–ª–µ–Ω –≤ –±–ª–æ–∫-–ª–∏—Å—Ç —Ä–∞—Å—Å—ã–ª–æ–∫.", reply_markup=admin_mailing_keyboard())


@router.message(AdminStates.MAILING_MENU, F.text == "‚úÖ –í–∫–ª—é—á–∏—Ç—å –æ–±—Ä–∞—Ç–Ω–æ ID/@username")
async def admin_mailing_unblock_start(message: Message, state: FSMContext) -> None:
    session = await _ensure_admin_session_message(message, state, min_level=1)
    if not session:
        return
    await state.set_state(AdminStates.MAILING_UNBLOCK_WAIT_USER)
    await message.answer(
        "–û—Ç–ø—Ä–∞–≤—å—Ç–µ ID –∏–ª–∏ @username –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, –∫–æ—Ç–æ—Ä–æ–≥–æ –Ω—É–∂–Ω–æ –≤–µ—Ä–Ω—É—Ç—å –≤ —Ä–∞—Å—Å—ã–ª–∫–∏."
    )


@router.message(AdminStates.MAILING_UNBLOCK_WAIT_USER)
async def admin_mailing_unblock_process(message: Message, state: FSMContext) -> None:
    session = await _ensure_admin_session_message(message, state, min_level=1)
    if not session:
        return
    text_raw = (message.text or "").strip()
    if not text_raw:
        await message.answer("–í–≤–µ–¥–∏—Ç–µ ID –∏–ª–∏ username.")
        return
    ident = text_raw
    blocklist = _load_broadcast_blocklist()
    ids = set(blocklist.get("ids", []))
    usernames = set(blocklist.get("usernames", []))
    if ident.lstrip("@").isdigit():
        ids.discard(int(ident.lstrip("@")))
    else:
        usernames.discard(ident.lstrip("@").lower())
    _save_broadcast_blocklist({"ids": list(ids), "usernames": list(usernames)})
    await state.set_state(AdminStates.MAILING_MENU)
    await message.answer("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–¥–∞–ª—ë–Ω –∏–∑ –±–ª–æ–∫-–ª–∏—Å—Ç–∞ —Ä–∞—Å—Å—ã–ª–æ–∫.", reply_markup=admin_mailing_keyboard())


@router.message(Command("logout"))
@router.message(F.text.in_({"‚èèÔ∏è –í—ã–π—Ç–∏ –∏–∑ –ø–∞–Ω–µ–ª–∏", "‚¨ÖÔ∏è –í—ã–π—Ç–∏ –∏–∑ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª–∏"}))
async def admin_exit(message: Message, state: FSMContext) -> None:
    ctx = get_context()
    await ctx.db.deactivate_admin_sessions_for_user(message.from_user.id)
    await state.set_state(MenuStates.MAIN)
    await message.bot.set_my_commands(
        get_default_bot_commands(),
        scope=BotCommandScopeChat(chat_id=message.chat.id),
    )
    await message.answer("‚úÖ –í—ã –≤—ã—à–ª–∏ –∏–∑ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª–∏.", reply_markup=main_menu_keyboard())


@router.message(AdminStates.MAIN)
async def admin_unknown(message: Message, state: FSMContext) -> None:
    session = await _ensure_admin_session_message(message, state)
    if not session:
        return
    await message.answer(
        "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫–∏ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª–∏ –≤–Ω–∏–∑—É.\n"
        "–ù–∞–ø—Ä–∏–º–µ—Ä, –æ—Ç–∫—Ä–æ–π—Ç–µ –Ω—É–∂–Ω—ã–π —Ä–∞–∑–¥–µ–ª.",
        reply_markup=admin_main_keyboard(session["level"]),
    )


@router.message(
    AdminStates.USER_SYSTEM_MENU,
    F.text,
    ~F.text.startswith("/"),
    ~F.text.in_(
        {
            "üë• –°–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π",
            "üîç –ü–æ–∏—Å–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è",
            "üßë‚Äçüíª –°–µ—Å—Å–∏–∏ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–≤",
            "‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –≤ –∞–¥–º–∏–Ω-–º–µ–Ω—é",
        }
    ),
)
async def admin_unknown_user_system(message: Message, state: FSMContext) -> None:
    session = await _ensure_admin_session_message(message, state)
    if not session:
        return
    level = session.get("level", 1)
    await message.answer(
        "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫–∏ —Ä–∞–∑–¥–µ–ª–∞ ¬´–°–∏—Å—Ç–µ–º–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π¬ª.",
        reply_markup=admin_user_system_keyboard(level),
    )


@router.message(
    AdminStates.SCHEDULE_MENU,
    F.text,
    ~F.text.startswith("/"),
    ~F.text.in_(
        {
            "üîÑ –ü–µ—Ä–µ–ø–∞—Ä—Å–∏—Ç—å —Ç–µ–∫—É—â–µ–µ",
            "üóë –£–¥–∞–ª–∏—Ç—å —Å—Ç–∞—Ä—ã–µ —Ñ–∞–π–ª—ã",
            "üìã –ü—Ä–æ—Å–º–æ—Ç—Ä–µ—Ç—å –∞–∫—Ç–∏–≤–Ω—ã–µ –ø–æ–¥–ø–∏—Å–∫–∏",
            "‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –≤ –∞–¥–º–∏–Ω-–º–µ–Ω—é",
        }
    ),
)
async def admin_unknown_schedule_menu(message: Message, state: FSMContext) -> None:
    session = await _ensure_admin_session_message(message, state, min_level=2)
    if not session:
        return
    await message.answer(
        "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫–∏ —Ä–∞–∑–¥–µ–ª–∞ ¬´–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ–º¬ª.",
        reply_markup=admin_schedule_keyboard(),
    )


@router.message(
    AdminStates.LOGS_MENU,
    F.text,
    ~F.text.startswith("/"),
    ~F.text.in_(
        {
            "‚è±Ô∏è –ü–æ–∫–∞–∑–∞—Ç—å uptime",
            "üìú –ü–æ–∫–∞–∑–∞—Ç—å –ø–æ—Å–ª–µ–¥–Ω–∏–µ N —Å—Ç—Ä–æ–∫ –ª–æ–≥–æ–≤",
            "üß† –ü–∞–º—è—Ç—å –∏ CPU",
            "üì• –°–∫–∞—á–∞—Ç—å –≤–µ—Å—å –ª–æ–≥",
            "üßë‚Äçüíª –õ–æ–≥–∏ –æ—à–∏–±–æ–∫ –ª—é–¥–µ–π",
            "‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –≤ –∞–¥–º–∏–Ω-–º–µ–Ω—é",
        }
    ),
)
async def admin_unknown_logs_menu(message: Message, state: FSMContext) -> None:
    session = await _ensure_admin_session_message(message, state)
    if not session:
        return
    await message.answer(
        "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫–∏ —Ä–∞–∑–¥–µ–ª–∞ ¬´–õ–æ–≥–∏ –∏ —Å—Ç–∞—Ç—É—Å¬ª.",
        reply_markup=admin_logs_keyboard(),
    )


@router.message(
    AdminStates.BAN_MENU,
    F.text,
    ~F.text.startswith("/"),
    ~F.text.in_(
        {
            "üö´ –ë–∞–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è",
            "‚úÖ –†–∞–∑–±–∞–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è",
            "üìã –°–ø–∏—Å–æ–∫ –∑–∞–±–∞–Ω–µ–Ω–Ω—ã—Ö",
            "‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –≤ –∞–¥–º–∏–Ω-–º–µ–Ω—é",
        }
    ),
)
async def admin_unknown_ban_menu(message: Message, state: FSMContext) -> None:
    session = await _ensure_admin_session_message(message, state, min_level=2)
    if not session:
        return
    await message.answer(
        "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫–∏ —Ä–∞–∑–¥–µ–ª–∞ ¬´–ë–∞–Ω / –†–∞–∑–±–∞–Ω¬ª.",
        reply_markup=admin_ban_keyboard(),
    )


@router.message(
    AdminStates.MAILING_MENU,
    F.text,
    ~F.text.startswith("/"),
    ~F.text.in_(
        {
            "üö´ –û—Ç–∫–ª—é—á–∏—Ç—å —Ä–∞—Å—Å—ã–ª–∫—É –¥–ª—è ID/@username",
            "‚úÖ –í–∫–ª—é—á–∏—Ç—å –æ–±—Ä–∞—Ç–Ω–æ ID/@username",
            "üìã –ü–æ–∫–∞–∑–∞—Ç—å –∏—Å–∫–ª—é—á–µ–Ω–∏—è",
            "‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –≤ –∞–¥–º–∏–Ω-–º–µ–Ω—é",
        }
    ),
)
async def admin_unknown_mailing_menu(message: Message, state: FSMContext) -> None:
    session = await _ensure_admin_session_message(message, state, min_level=1)
    if not session:
        return
    await message.answer(
        "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫–∏ —Ä–∞–∑–¥–µ–ª–∞ ¬´–ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Ä–∞—Å—Å—ã–ª–∫–∏¬ª.",
        reply_markup=admin_mailing_keyboard(),
    )


@router.callback_query(F.data.startswith("admin_users_prev:"))
async def admin_users_prev(callback: CallbackQuery, state: FSMContext) -> None:
    session = await _ensure_admin_session_callback(callback, state)
    if not session:
        return
    parts = callback.data.split(":", 1)
    try:
        page = int(parts[1])
    except Exception:
        page = 1
    ctx = get_context()
    per_page = 20
    _, total, pages = await ctx.db.list_users_page(page, per_page)
    if total == 0 or pages == 0:
        await callback.answer("–°–ø–∏—Å–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –ø—É—Å—Ç.", show_alert=True)
        return
    prev_page = page - 1 if page > 1 else pages
    users, total, pages = await ctx.db.list_users_page(prev_page, per_page)
    text = _format_users_table(users, start_index=(prev_page - 1) * per_page + 1)
    markup = admin_users_inline_keyboard(prev_page, pages)
    await callback.message.edit_text(text, reply_markup=markup)
    await callback.answer()


@router.callback_query(F.data.startswith("admin_users_next:"))
async def admin_users_next(callback: CallbackQuery, state: FSMContext) -> None:
    session = await _ensure_admin_session_callback(callback, state)
    if not session:
        return
    parts = callback.data.split(":", 1)
    try:
        page = int(parts[1])
    except Exception:
        page = 1
    ctx = get_context()
    per_page = 20
    _, total, pages = await ctx.db.list_users_page(page, per_page)
    if total == 0 or pages == 0:
        await callback.answer("–°–ø–∏—Å–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –ø—É—Å—Ç.", show_alert=True)
        return
    next_page = page + 1 if page < pages else 1
    users, total, pages = await ctx.db.list_users_page(next_page, per_page)
    text = _format_users_table(users, start_index=(next_page - 1) * per_page + 1)
    markup = admin_users_inline_keyboard(next_page, pages)
    await callback.message.edit_text(text, reply_markup=markup)
    await callback.answer()


@router.callback_query(F.data.startswith("admin_users_info:"))
async def admin_users_info(callback: CallbackQuery, state: FSMContext) -> None:
    session = await _ensure_admin_session_callback(callback, state)
    if not session:
        return
    parts = callback.data.split(":", 1)
    try:
        page = int(parts[1])
    except Exception:
        page = 1
    ctx = get_context()
    per_page = 20
    users, total, pages = await ctx.db.list_users_page(page, per_page)
    stats = await ctx.db.get_users_stats()
    if pages == 0:
        pages = 1
    blocked_on_page = sum(1 for u in users if u.get("is_blocked"))
    admins_on_page = sum(1 for u in users if u.get("is_admin"))
    lines = [
        "üìä <b>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π</b>",
        "",
        f"üë• –í—Å–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: <b>{stats['total']}</b>",
        f"üö´ –ó–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–ª–∏ –±–æ—Ç–∞: <b>{stats['blocked']}</b>",
        f"üè∑ –° —É–∫–∞–∑–∞–Ω–Ω–æ–π –≥—Ä—É–ø–ø–æ–π: <b>{stats['with_group']}</b>",
        f"üßë‚Äçüíª –ê–∫—Ç–∏–≤–Ω—ã—Ö –∞–¥–º–∏–Ω-—Å–µ—Å—Å–∏–π: <b>{stats['active_admins']}</b>",
        "",
        f"üìÑ –°—Ç—Ä–∞–Ω–∏—Ü –≤—Å–µ–≥–æ: <b>{pages}</b>",
        "",
        f"üìÑ –¢–µ–∫—É—â–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞: <b>{page}</b>/<b>{pages}</b>",
        f"üë• –ù–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–µ: <b>{len(users)}</b>",
        f"üö´ –ó–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–æ –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–µ: <b>{blocked_on_page}</b>",
        f"üßë‚Äçüíª –ê–¥–º–∏–Ω–æ–≤ –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–µ: <b>{admins_on_page}</b>",
    ]
    await callback.message.answer("\n".join(lines))
    await callback.answer()


@router.callback_query(F.data.startswith("admin_kill_session:"))
async def admin_kill_session(callback: CallbackQuery, state: FSMContext) -> None:
    session = await _ensure_admin_session_callback(callback, state, min_level=3)
    if not session:
        return
    parts = callback.data.split(":", 1)
    try:
        session_id = int(parts[1])
    except Exception:
        await callback.answer("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä —Å–µ—Å—Å–∏–∏.", show_alert=True)
        return
    ctx = get_context()
    target_session = await ctx.db.get_admin_session_by_id(session_id)
    if not target_session or not target_session.get("active"):
        sessions = await ctx.db.get_active_admin_sessions_with_users()
        text = _format_admin_sessions_text(sessions)
        markup = admin_sessions_keyboard(sessions)
        await callback.message.edit_text(text, reply_markup=markup)
        await callback.answer("–°–µ—Å—Å–∏—è —É–∂–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∞.", show_alert=True)
        return
    await ctx.db.deactivate_admin_session_by_id(session_id)
    target_tg_id = target_session["tg_id"]
    try:
        await callback.bot.set_my_commands(
            get_default_bot_commands(),
            scope=BotCommandScopeChat(chat_id=target_tg_id),
        )
        ctx_app = get_context()
        storage = getattr(ctx_app, "storage", None)
        if storage is not None:
            key = StorageKey(
                bot_id=callback.bot.id,
                chat_id=target_tg_id,
                user_id=target_tg_id,
                destiny="default",
            )
            remote_state = FSMContext(storage=storage, key=key)
            await remote_state.clear()
            await remote_state.set_state(MenuStates.MAIN)
        await callback.bot.send_message(
            target_tg_id,
            "–í–∞—à–∞ —Å–µ—Å—Å–∏—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞ –±—ã–ª–∞ –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ —É–¥–∞–ª–µ–Ω–∞.",
            reply_markup=main_menu_keyboard(),
        )
    except Exception:
        pass
    sessions = await ctx.db.get_active_admin_sessions_with_users()
    text = _format_admin_sessions_text(sessions)
    markup = admin_sessions_keyboard(sessions)
    await callback.message.edit_text(text, reply_markup=markup)
    await callback.answer("–°–µ—Å—Å–∏—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞.", show_alert=True)


@router.callback_query(F.data == "admin_sessions_refresh")
async def admin_sessions_refresh(callback: CallbackQuery, state: FSMContext) -> None:
    session = await _ensure_admin_session_callback(callback, state, min_level=3)
    if not session:
        return
    ctx = get_context()
    sessions = await ctx.db.get_active_admin_sessions_with_users()
    text = _format_admin_sessions_text(sessions)
    markup = admin_sessions_keyboard(sessions)
    await callback.message.edit_text(text, reply_markup=markup)
    await callback.answer()


@router.callback_query(F.data == "broadcast_cancel")
async def admin_broadcast_cancel_callback(callback: CallbackQuery, state: FSMContext) -> None:
    session = await _ensure_admin_session_callback(callback, state, min_level=2)
    if not session:
        return
    level = session.get("level", 1)
    await state.set_state(AdminStates.MAIN)
    await callback.answer("–†–∞—Å—Å—ã–ª–∫–∞ –æ—Ç–º–µ–Ω–µ–Ω–∞.", show_alert=False)
    try:
        await callback.message.delete()
    except Exception:
        pass
    await callback.message.answer(
        "–†–∞—Å—Å—ã–ª–∫–∞ –æ—Ç–º–µ–Ω–µ–Ω–∞.",
        reply_markup=admin_main_keyboard(level),
    )

11. app/handlers/common.py  (15.4KB, 2025-11-26 22:27:22)
   –†–æ–ª—å: Router ‚Ä¢ Text/UI
   –ò–º–ø–æ—Ä—Ç—ã (–ª–æ–∫–∞–ª—å–Ω—ã–µ): app.core.context, app.core.states, app.handlers.admin, app.keyboards.admin, app.keyboards.reply
   –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ—Ç—Å—è –º–æ–¥—É–ª—è–º–∏: app.handlers.__init__
–ö–æ–¥:
from aiogram import Router, F
from aiogram.filters import Command
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import StatesGroup, State
from aiogram.types import Message

from app.core.context import get_context
from app.core.states import MenuStates, PersonalCabinetStates
from app.keyboards.admin import admin_main_keyboard
from app.keyboards.reply import (
    main_menu_keyboard,
    schedule_keyboard,
    personal_cabinet_keyboard,
    personal_settings_keyboard,
)
from app.handlers.admin import _load_categories_config

router = Router()


class SetGroupStates(StatesGroup):
    waiting_for_group = State()


async def _build_personal_cabinet_text(message: Message) -> str:
    ctx = get_context()
    user = await ctx.db.get_user(message.from_user.id)
    group_code = user["group_code"] if user else None
    group_text = group_code if group_code else "–Ω–µ —É–∫–∞–∑–∞–Ω–∞"
    premium_until = await ctx.db.get_user_premium_until(message.from_user.id)
    if premium_until:
        premium_str = premium_until.strftime("%d.%m.%Y")
        premium_line = f"–°—Ç–∞—Ç—É—Å –ø—Ä–µ–º–∏—É–º: ‚úÖ –¥–æ {premium_str}"
    else:
        premium_line = "–°—Ç–∞—Ç—É—Å –ø—Ä–µ–º–∏—É–º: ‚ùå –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–π –ø–æ–¥–ø–∏—Å–∫–∏"
    steward_group = await ctx.db.get_steward_group(message.from_user.id)
    if steward_group:
        steward_line = f"–†–æ–ª—å: –≤—ã —è–≤–ª—è–µ—Ç–µ—Å—å —Å—Ç–∞—Ä–æ—Å—Ç–æ–π –≥—Ä—É–ø–ø—ã {steward_group}"
    else:
        steward_line = None
    notify_enabled = await ctx.db.get_schedule_notify_enabled(message.from_user.id)
    notify_line = (
        "–£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ–± –∏–∑–º–µ–Ω–µ–Ω–∏–∏ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è: –≤–∫–ª—é—á–µ–Ω—ã"
        if notify_enabled
        else "–£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ–± –∏–∑–º–µ–Ω–µ–Ω–∏–∏ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è: –≤—ã–∫–ª—é—á–µ–Ω—ã"
    )
    lines: list[str] = [
        "<b>–õ–∏—á–Ω—ã–π –∫–∞–±–∏–Ω–µ—Ç</b>",
        "",
        f"–í–∞—à–∞ –≥—Ä—É–ø–ø–∞ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é: <b>{group_text}</b>",
        "",
        premium_line,
        notify_line,
    ]
    if steward_line:
        lines.append(steward_line)
    return "\n".join(lines)


async def _keyboard_for_current_menu(state: FSMContext):
    current_state = await state.get_state()
    if current_state == MenuStates.SCHEDULE.state:
        return schedule_keyboard()
    return main_menu_keyboard()


async def _keyboard_after_set_group(message: Message, state: FSMContext):
    ctx = get_context()
    admin_session = await ctx.db.get_active_admin_session_for_user(message.from_user.id)
    if admin_session:
        return admin_main_keyboard(admin_session["level"])
    return await _keyboard_for_current_menu(state)


@router.message(Command("help"))
async def cmd_help(message: Message, state: FSMContext) -> None:
    ctx = get_context()
    admin_session = await ctx.db.get_active_admin_session_for_user(message.from_user.id)
    if admin_session:
        kb = admin_main_keyboard(admin_session["level"])
        text = (
            "<b>–ù–ú–ö –ü–æ–º–æ—â–Ω–∏–∫ ‚Äî —Ä–µ–∂–∏–º –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞</b>\n\n"
            "–û—Å–Ω–æ–≤–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:\n"
            "/start ‚Äî –≤–µ—Ä–Ω—É—Ç—å—Å—è –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é\n"
            "/help ‚Äî —ç—Ç–∞ —Å–ø—Ä–∞–≤–∫–∞\n"
            "/setmygroup ‚Äî —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —É—á–µ–±–Ω—É—é –≥—Ä—É–ø–ø—É –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é\n"
            "/promo ‚Äî –≤–≤–µ—Å—Ç–∏ –ø—Ä–æ–º–æ–∫–æ–¥\n"
            "/adminpanel ‚Äî –æ—Ç–∫—Ä—ã—Ç—å –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å\n"
            "/ai_logs ‚Äî –ø—Ä–æ—Å–º–æ—Ç—Ä –ª–æ–≥–æ–≤ AI-–ø—Ä–æ–≤–µ—Ä–∫–∏ –¥–æ–º–∞—à–∫–∏\n"
            "/givepremium ‚Äî –≤—ã–¥–∞—Ç—å –ø—Ä–µ–º–∏—É–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é\n\n"
            "–ì–ª–∞–≤–Ω—ã–µ —Ä–∞–∑–¥–µ–ª—ã –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª–∏:\n"
            "‚Ä¢ ¬´üß© –°–∏—Å—Ç–µ–º–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π¬ª ‚Äî —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º–∏\n"
            "‚Ä¢ ¬´üìä –õ–æ–≥–∏ –∏ —Å—Ç–∞—Ç—É—Å¬ª ‚Äî —Å–∏—Å—Ç–µ–º–Ω—ã–µ –ª–æ–≥–∏ –∏ —Ä–µ—Å—É—Ä—Å—ã\n"
            "‚Ä¢ ¬´üìÖ –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ–º¬ª ‚Äî —Ä–∞–±–æ—Ç–∞ —Å –ø–æ–¥–ø–∏—Å–∫–∞–º–∏ –∏ —Ñ–∞–π–ª–∞–º–∏ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è\n"
            "‚Ä¢ ¬´üì¢ –†–∞—Å—Å—ã–ª–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π¬ª –∏ ¬´‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Ä–∞—Å—Å—ã–ª–∫–∏¬ª ‚Äî –º–∞—Å—Å–æ–≤—ã–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è\n"
            "‚Ä¢ ¬´üö´ –ë–∞–Ω / –†–∞–∑–±–∞–Ω¬ª ‚Äî –±–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π\n"
            "‚Ä¢ ¬´‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –∫–∞—Ç–µ–≥–æ—Ä–∏–π¬ª ‚Äî –≤–∫–ª—é—á–µ–Ω–∏–µ/–≤—ã–∫–ª—é—á–µ–Ω–∏–µ —Ä–∞–∑–¥–µ–ª–æ–≤ (–≤ —Ç–æ–º —á–∏—Å–ª–µ –î–æ–º–∞—à–∫–∞üìö)\n\n"
            "–†–∞–∑–¥–µ–ª ¬´–î–æ–º–∞—à–∫–∞üìö¬ª –≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–º –º–µ–Ω—é:\n"
            "‚Ä¢ –õ–∏—á–Ω–∞—è –¥–æ–º–∞—à–∫–∞ (–ø—Ä–µ–º–∏—É–º)\n"
            "‚Ä¢ –û–±—â–∞—è –¥–æ–º–∞—à–∫–∞ –ø–æ –≥—Ä—É–ø–ø–µ —Å AI-–ø—Ä–æ–≤–µ—Ä–∫–æ–π –∏ –º–æ–¥–µ—Ä–∞—Ü–∏–µ–π."
        )
    else:
        kb = await _keyboard_for_current_menu(state)
        text = (
            "<b>–ù–ú–ö –ü–æ–º–æ—â–Ω–∏–∫</b> ‚Äî –≤–∞—à –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç –¥–ª—è —É—á—ë–±—ã.\n\n"
            "–û—Å–Ω–æ–≤–Ω—ã–µ —Ä–∞–∑–¥–µ–ª—ã:\n"
            "‚Ä¢ ¬´–†–∞—Å–ø–∏—Å–∞–Ω–∏–µüìã¬ª ‚Äî —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–∞ —Å–µ–≥–æ–¥–Ω—è, –∑–∞–≤—Ç—Ä–∞ –∏ –Ω–µ–¥–µ–ª—é\n"
            "‚Ä¢ ¬´–î–æ–º–∞—à–∫–∞üìö¬ª ‚Äî –ª–∏—á–Ω—ã–µ –∏ –æ–±—â–∏–µ –¥–æ–º–∞—à–Ω–∏–µ –∑–∞–¥–∞–Ω–∏—è\n"
            "‚Ä¢ ¬´–õ–∏—á–Ω—ã–π –∫–∞–±–∏–Ω–µ—Çüë§¬ª ‚Äî –≤–∞—à–∞ –≥—Ä—É–ø–ø–∞ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏\n\n"
            "–ö–æ–º–∞–Ω–¥—ã:\n"
            "/start ‚Äî –∑–∞–ø—É—Å–∫ –±–æ—Ç–∞ –∏ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é\n"
            "/help ‚Äî —ç—Ç–∞ —Å–ø—Ä–∞–≤–∫–∞\n"
            "/setmygroup ‚Äî —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —É—á–µ–±–Ω—É—é –≥—Ä—É–ø–ø—É –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é\n"
            "/promo ‚Äî –≤–≤–µ—Å—Ç–∏ –ø—Ä–æ–º–æ–∫–æ–¥ (–µ—Å–ª–∏ –µ—Å—Ç—å –∞–∫—Ü–∏–∏)\n\n"
            "–õ–∏—á–Ω–∞—è –¥–æ–º–∞—à–∫–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ –ø—Ä–µ–º–∏—É–º-–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º, –æ–±—â–∞—è –¥–æ–º–∞—à–∫–∞ ‚Äî –≤—Å–µ–º —Å—Ç—É–¥–µ–Ω—Ç–∞–º –≥—Ä—É–ø–ø—ã."
        )
    await message.answer(text, reply_markup=kb)


@router.message(Command("promo"))
async def cmd_promo(message: Message, state: FSMContext) -> None:
    kb = await _keyboard_for_current_menu(state)
    text = "–°–µ–π—á–∞—Å –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –ø—Ä–æ–º–æ–∞–∫—Ü–∏–π. –°–ª–µ–¥–∏—Ç–µ –∑–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è–º–∏ –ù–ú–ö –ü–æ–º–æ—â–Ω–∏–∫–∞."
    await message.answer(text, reply_markup=kb)


@router.message(Command("setmygroup"))
async def cmd_setmygroup(message: Message, state: FSMContext) -> None:
    ctx = get_context()
    current_state = await state.get_state()
    parts = (message.text or "").split(maxsplit=1)
    if len(parts) > 1:
        raw_group = parts[1].strip()
        if raw_group.endswith("."):
            raw_group = raw_group[:-1].strip()
        canonical = ctx.group_resolver.resolve(raw_group)
        if not canonical:
            await message.answer(
                "–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å —Ç–∞–∫—É—é –≥—Ä—É–ø–ø—É. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –Ω–∞–ø–∏—Å–∞–Ω–∏–µ –∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑ –∫–æ–º–∞–Ω–¥–æ–π /setmygroup."
            )
            return
        await ctx.db.set_user_group(message.from_user.id, canonical)
        kb = await _keyboard_after_set_group(message, state)
        text = (
            f"–ì—Ä—É–ø–ø–∞ <b>{canonical}</b> —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é.\n"
            "–í—ã –º–æ–∂–µ—Ç–µ –∏–∑–º–µ–Ω–∏—Ç—å –µ—ë –≤ –ª—é–±–æ–µ –≤—Ä–µ–º—è, —Å–Ω–æ–≤–∞ –≤—ã–∑–≤–∞–≤ –∫–æ–º–∞–Ω–¥—É /setmygroup."
        )
        await message.answer(text, reply_markup=kb)
        return
    await state.update_data(prev_state=current_state)
    await state.set_state(SetGroupStates.waiting_for_group)
    text = (
        "–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ —Ç–æ–ª—å–∫–æ —Å –Ω–∞–∑–≤–∞–Ω–∏–µ–º –≤–∞—à–µ–π —É—á–µ–±–Ω–æ–π –≥—Ä—É–ø–ø—ã.\n"
        "–ù–∞–ø—Ä–∏–º–µ—Ä: <b>–ò–°-131</b>"
    )
    await message.answer(text)


@router.message(SetGroupStates.waiting_for_group)
async def process_group_input(message: Message, state: FSMContext) -> None:
    ctx = get_context()
    text_raw = message.text or ""
    if text_raw.startswith("/"):
        return
    raw_group = text_raw.strip()
    canonical = ctx.group_resolver.resolve(raw_group)
    if not canonical:
        await message.answer(
            "–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å —Ç–∞–∫—É—é –≥—Ä—É–ø–ø—É. –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ –≥—Ä—É–ø–ø–∞ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –∏ –Ω–∞–ø–∏—Å–∞–Ω–∞ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ, –∑–∞—Ç–µ–º –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –µ—ë –µ—â—ë —Ä–∞–∑."
        )
        return
    data = await state.get_data()
    prev_state = data.get("prev_state")
    await ctx.db.set_user_group(message.from_user.id, canonical)
    if prev_state:
        await state.set_state(prev_state)
        await state.update_data(prev_state=None)
    else:
        await state.set_state(MenuStates.MAIN)
    kb = await _keyboard_after_set_group(message, state)
    text = (
        f"–ì—Ä—É–ø–ø–∞ <b>{canonical}</b> —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é.\n"
        "–í—ã –º–æ–∂–µ—Ç–µ –∏–∑–º–µ–Ω–∏—Ç—å –µ—ë –≤ –ª—é–±–æ–µ –≤—Ä–µ–º—è, —Å–Ω–æ–≤–∞ –≤—ã–∑–≤–∞–≤ –∫–æ–º–∞–Ω–¥—É /setmygroup."
    )
    await message.answer(text, reply_markup=kb)


@router.message(MenuStates.MAIN, F.text == "–õ–∏—á–Ω—ã–π –∫–∞–±–∏–Ω–µ—Çüë§")
async def personal_cabinet(message: Message, state: FSMContext) -> None:
    await state.set_state(PersonalCabinetStates.MENU)
    text = await _build_personal_cabinet_text(message)
    await message.answer(text, reply_markup=personal_cabinet_keyboard())


@router.message(PersonalCabinetStates.MENU, F.text == "‚¨ÖÔ∏è –í—ã–π—Ç–∏ –Ω–∞–∑–∞–¥")
async def personal_cabinet_back_to_main(message: Message, state: FSMContext) -> None:
    await state.set_state(MenuStates.MAIN)
    await message.answer("–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é –ù–ú–ö –ü–æ–º–æ—â–Ω–∏–∫–∞.", reply_markup=main_menu_keyboard())


@router.message(PersonalCabinetStates.MENU, F.text == "–ü—Ä–µ–º–∏—É–º")
async def personal_cabinet_premium(message: Message) -> None:
    text = await _build_personal_cabinet_text(message)
    await message.answer(text, reply_markup=personal_cabinet_keyboard())


@router.message(PersonalCabinetStates.MENU, F.text == "–ù–∞—Å—Ç—Ä–æ–π–∫–∏")
async def personal_cabinet_settings(message: Message, state: FSMContext) -> None:
    ctx = get_context()
    user = await ctx.db.get_user(message.from_user.id)
    group_code = user["group_code"] if user else None
    has_group = bool(group_code)
    notify_enabled = await ctx.db.get_schedule_notify_enabled(message.from_user.id)
    group_text = group_code if group_code else "–Ω–µ —É–∫–∞–∑–∞–Ω–∞"
    lines: list[str] = [
        "<b>–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ª–∏—á–Ω–æ–≥–æ –∫–∞–±–∏–Ω–µ—Ç–∞</b>",
        "",
        f"–¢–µ–∫—É—â–∞—è –≥—Ä—É–ø–ø–∞ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é: <b>{group_text}</b>",
        "–£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ–± –∏–∑–º–µ–Ω–µ–Ω–∏–∏ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è: –≤–∫–ª—é—á–µ–Ω—ã"
        if notify_enabled
        else "–£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ–± –∏–∑–º–µ–Ω–µ–Ω–∏–∏ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è: –≤—ã–∫–ª—é—á–µ–Ω—ã",
    ]
    text = "\n".join(lines)
    await state.set_state(PersonalCabinetStates.SETTINGS)
    await message.answer(text, reply_markup=personal_settings_keyboard(has_group, notify_enabled))


@router.message(PersonalCabinetStates.SETTINGS, F.text == "‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –≤ –ª–∏—á–Ω—ã–π –∫–∞–±–∏–Ω–µ—Ç")
async def personal_settings_back_to_cabinet(message: Message, state: FSMContext) -> None:
    await state.set_state(PersonalCabinetStates.MENU)
    text = await _build_personal_cabinet_text(message)
    await message.answer(text, reply_markup=personal_cabinet_keyboard())


@router.message(PersonalCabinetStates.SETTINGS, F.text.contains("–£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–∏"))
async def personal_settings_toggle_notifications(message: Message, state: FSMContext) -> None:
    ctx = get_context()
    current = await ctx.db.get_schedule_notify_enabled(message.from_user.id)
    new_value = not current
    await ctx.db.set_schedule_notify_enabled(message.from_user.id, new_value)
    user = await ctx.db.get_user(message.from_user.id)
    group_code = user["group_code"] if user else None
    has_group = bool(group_code)
    status_text = "–≤–∫–ª—é—á–µ–Ω—ã" if new_value else "–≤—ã–∫–ª—é—á–µ–Ω—ã"
    await message.answer(
        f"–£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ–± –∏–∑–º–µ–Ω–µ–Ω–∏–∏ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è —Ç–µ–ø–µ—Ä—å {status_text}.",
        reply_markup=personal_settings_keyboard(has_group, new_value),
    )


@router.message(
    PersonalCabinetStates.SETTINGS,
    F.text.in_({"–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –≥—Ä—É–ø–ø—É", "–ò–∑–º–µ–Ω–∏—Ç—å –≥—Ä—É–ø–ø—É"}),
)
async def personal_settings_set_group_start(message: Message, state: FSMContext) -> None:
    await state.set_state(PersonalCabinetStates.SETTINGS_WAIT_GROUP)
    await message.answer(
        "–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ —Ç–æ–ª—å–∫–æ —Å –Ω–∞–∑–≤–∞–Ω–∏–µ–º –≤–∞—à–µ–π —É—á–µ–±–Ω–æ–π –≥—Ä—É–ø–ø—ã.\n"
        "–ù–∞–ø—Ä–∏–º–µ—Ä: <b>–ò–°-131</b>"
    )


@router.message(PersonalCabinetStates.SETTINGS_WAIT_GROUP)
async def personal_settings_group_input(message: Message, state: FSMContext) -> None:
    if (message.text or "") == "‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –≤ –ª–∏—á–Ω—ã–π –∫–∞–±–∏–Ω–µ—Ç":
        await state.set_state(PersonalCabinetStates.MENU)
        text = await _build_personal_cabinet_text(message)
        await message.answer(text, reply_markup=personal_cabinet_keyboard())
        return
    text_raw = message.text or ""
    if text_raw.startswith("/"):
        return
    ctx = get_context()
    raw_group = text_raw.strip()
    canonical = ctx.group_resolver.resolve(raw_group)
    if not canonical:
        await message.answer(
            "–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å —Ç–∞–∫—É—é –≥—Ä—É–ø–ø—É. –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ –≥—Ä—É–ø–ø–∞ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –∏ –Ω–∞–ø–∏—Å–∞–Ω–∞ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ, –∑–∞—Ç–µ–º –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –µ—ë –µ—â—ë —Ä–∞–∑."
        )
        return
    await ctx.db.set_user_group(message.from_user.id, canonical)
    notify_enabled = await ctx.db.get_schedule_notify_enabled(message.from_user.id)
    await state.set_state(PersonalCabinetStates.SETTINGS)
    await message.answer(
        f"–ì—Ä—É–ø–ø–∞ <b>{canonical}</b> —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é.",
        reply_markup=personal_settings_keyboard(True, notify_enabled),
    )


@router.message(MenuStates.MAIN, F.text == "–†–∞—Å–ø–∏—Å–∞–Ω–∏–µüìã")
async def schedule_entry(message: Message, state: FSMContext) -> None:
    cfg = _load_categories_config()
    info = cfg.get("–†–∞—Å–ø–∏—Å–∞–Ω–∏–µüìã", {})
    enabled = bool(info.get("enabled", True))
    if not enabled:
        disabled_text = info.get("disabled_text") or "–§—É–Ω–∫—Ü–∏—è –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞."
        await message.answer(disabled_text, reply_markup=main_menu_keyboard())
        return
    await state.set_state(MenuStates.SCHEDULE)
    text = "–í—ã–±–µ—Ä–∏—Ç–µ –ø–µ—Ä–∏–æ–¥, –∑–∞ –∫–æ—Ç–æ—Ä—ã–π –ø–æ–∫–∞–∑–∞—Ç—å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ."
    await message.answer(text, reply_markup=schedule_keyboard())


@router.message(
    MenuStates.MAIN,
    F.text,
    ~F.text.startswith("/"),
    ~F.text.in_({"–†–∞—Å–ø–∏—Å–∞–Ω–∏–µüìã", "–î–æ–º–∞—à–∫–∞üìö", "–õ–∏—á–Ω—ã–π –∫–∞–±–∏–Ω–µ—Çüë§"}),
)
async def unknown_main_menu(message: Message) -> None:
    await message.answer(
        "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫–∏ –≥–ª–∞–≤–Ω–æ–≥–æ –º–µ–Ω—é –≤–Ω–∏–∑—É.",
        reply_markup=main_menu_keyboard(),
    )


@router.message(
    MenuStates.SCHEDULE,
    F.text,
    ~F.text.startswith("/"),
    ~F.text.in_({"–°–µ–≥–æ–¥–Ω—è", "–ó–∞–≤—Ç—Ä–∞", "–ù–∞ –≤—Å—é –Ω–µ–¥–µ–ª—é", "–í—ã–π—Ç–∏ –Ω–∞–∑–∞–¥"}),
)
async def unknown_schedule_menu(message: Message) -> None:
    await message.answer(
        "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫–∏ –º–µ–Ω—é —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è.",
        reply_markup=schedule_keyboard(),
    )

12. app/handlers/homework.py  (24.8KB, 2025-11-26 22:50:47)
   –†–æ–ª—å: Router ‚Ä¢ Text/UI
   –ò–º–ø–æ—Ä—Ç—ã (–ª–æ–∫–∞–ª—å–Ω—ã–µ): app.core.context, app.core.states, app.handlers.admin, app.keyboards.admin, app.keyboards.homework, app.keyboards.reply
   –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ—Ç—Å—è –º–æ–¥—É–ª—è–º–∏: app.handlers.__init__
–ö–æ–¥:
import datetime as dt

from aiogram import Router, F
from aiogram.fsm.context import FSMContext
from aiogram.types import Message, CallbackQuery, ReplyKeyboardMarkup

from app.core.context import get_context
from app.core.states import MenuStates, HomeworkStates
from app.keyboards.reply import main_menu_keyboard
from app.keyboards.admin import admin_pending_inline
from app.keyboards.homework import (
    homework_main_keyboard,
    homework_personal_menu_keyboard,
    homework_personal_editor_keyboard,
    homework_personal_cancel_inline,
    homework_public_menu_keyboard,
    homework_public_suggest_cancel_inline,
    homework_subjects_keyboard,
    homework_edit_action_keyboard,
)
from app.handlers.admin import _load_categories_config

router = Router()


async def _is_steward_for_group(message: Message, group_code: str) -> bool:
    ctx = get_context()
    steward_group = await ctx.db.get_steward_group(message.from_user.id)
    if not steward_group:
        return False
    return steward_group.replace(" ", "").replace("-", "").upper() == group_code.replace(" ", "").replace("-", "").upper()


async def _public_menu_keyboard_for_user(message: Message) -> ReplyKeyboardMarkup:
    ctx = get_context()
    user = await ctx.db.get_user(message.from_user.id)
    group_code = user["group_code"] if user else None
    if not group_code:
        return homework_public_menu_keyboard(False)
    is_steward = await _is_steward_for_group(message, group_code)
    return homework_public_menu_keyboard(is_steward)


async def _ensure_group(message: Message) -> str | None:
    ctx = get_context()
    user = await ctx.db.get_user(message.from_user.id)
    group_code = user["group_code"] if user else None
    if not group_code:
        await message.answer(
            "–£ –≤–∞—Å –µ—â—ë –Ω–µ —É–∫–∞–∑–∞–Ω–∞ —É—á–µ–±–Ω–∞—è –≥—Ä—É–ø–ø–∞.\n\n"
            "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —Å–Ω–∞—á–∞–ª–∞ —É—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –≥—Ä—É–ø–ø—É –∫–æ–º–∞–Ω–¥–æ–π /setmygroup."
        )
        return None
    return group_code


@router.message(MenuStates.MAIN, F.text == "–î–æ–º–∞—à–∫–∞üìö")
async def homework_entry(message: Message, state: FSMContext) -> None:
    cfg = _load_categories_config()
    info = cfg.get("–î–æ–º–∞—à–∫–∞üìö", {})
    enabled = bool(info.get("enabled", True))
    if not enabled:
        disabled_text = info.get("disabled_text") or "–§—É–Ω–∫—Ü–∏—è –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞."
        await message.answer(disabled_text, reply_markup=main_menu_keyboard())
        return
    await state.set_state(HomeworkStates.MENU)
    await message.answer(
        "<b>–î–æ–º–∞—à–Ω–∏–µ –∑–∞–¥–∞–Ω–∏—è</b>\n\n"
        "–í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø –¥–æ–º–∞—à–Ω–µ–≥–æ –∑–∞–¥–∞–Ω–∏—è:\n"
        "‚Ä¢ üìò –õ–∏—á–Ω–∞—è –¥–æ–º–∞—à–∫–∞ (—Ç–æ–ª—å–∫–æ –¥–ª—è –≤–∞—Å)\n"
        "‚Ä¢ üìö –û–±—â–∞—è –¥–æ–º–∞—à–∫–∞ (–ø–æ –≥—Ä—É–ø–ø–µ, –≤–∏–¥–Ω–∞ –≤—Å–µ–º)",
        reply_markup=homework_main_keyboard(),
    )


@router.message(HomeworkStates.MENU, F.text == "‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é")
async def homework_back_to_main(message: Message, state: FSMContext) -> None:
    await state.set_state(MenuStates.MAIN)
    await message.answer("–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é –ù–ú–ö –ü–æ–º–æ—â–Ω–∏–∫–∞.", reply_markup=main_menu_keyboard())


@router.message(HomeworkStates.MENU, F.text == "üìò –õ–∏—á–Ω–∞—è –¥–æ–º–∞—à–∫–∞")
async def homework_personal_menu(message: Message, state: FSMContext) -> None:
    ctx = get_context()
    group_code = await _ensure_group(message)
    if not group_code:
        return
    is_premium = await ctx.homework_service.is_premium(message.from_user.id)
    if not is_premium:
        await message.answer(
            "‚ö†Ô∏è –õ–∏—á–Ω–∞—è –¥–æ–º–∞—à–∫–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –ø—Ä–µ–º–∏—É–º-–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º.\n\n"
            "–û–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ü–∏–∏, —á—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø –∫ –ø—Ä–µ–º–∏—É–º-—Ñ—É–Ω–∫—Ü–∏—è–º.",
            reply_markup=homework_main_keyboard(),
        )
        return
    await state.set_state(HomeworkStates.PERSONAL_MENU)
    await message.answer(
        "<b>–õ–∏—á–Ω–∞—è –¥–æ–º–∞—à–∫–∞</b>\n\n–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:",
        reply_markup=homework_personal_menu_keyboard(),
    )


@router.message(HomeworkStates.MENU, F.text == "üìö –û–±—â–∞—è –¥–æ–º–∞—à–∫–∞")
async def homework_public_menu(message: Message, state: FSMContext) -> None:
    group_code = await _ensure_group(message)
    if not group_code:
        return
    await state.set_state(HomeworkStates.PUBLIC_MENU)
    kb = await _public_menu_keyboard_for_user(message)
    await message.answer(
        "<b>–û–±—â–∞—è –¥–æ–º–∞—à–∫–∞</b>\n\n"
        "–î–æ–º–∞—à–Ω–∏–µ –∑–∞–¥–∞–Ω–∏—è, –ø—Ä–∏–≤—è–∑–∞–Ω–Ω—ã–µ –∫ –≤–∞—à–µ–π –≥—Ä—É–ø–ø–µ, –¥–æ—Å—Ç—É–ø–Ω—ã –≤—Å–µ–º —Å—Ç—É–¥–µ–Ω—Ç–∞–º —ç—Ç–æ–π –≥—Ä—É–ø–ø—ã.",
        reply_markup=kb,
    )


@router.message(HomeworkStates.PERSONAL_MENU, F.text == "‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é –¥–æ–º–∞—à–∫–∏")
async def homework_personal_back_to_hw_menu(message: Message, state: FSMContext) -> None:
    await state.set_state(HomeworkStates.MENU)
    await message.answer(
        "–í—ã –≤–µ—Ä–Ω—É–ª–∏—Å—å –≤ –º–µ–Ω—é –¥–æ–º–∞—à–∫–∏.",
        reply_markup=homework_main_keyboard(),
    )


@router.message(HomeworkStates.PERSONAL_MENU, F.text == "üîé –ü—Ä–æ—Å–º–æ—Ç—Ä –ª–∏—á–Ω–æ–π –¥–æ–º–∞—à–∫–∏")
async def homework_personal_view(message: Message) -> None:
    ctx = get_context()
    text = await ctx.homework_service.format_personal_view(message.from_user.id)
    await message.answer(text, disable_web_page_preview=True, reply_markup=homework_personal_menu_keyboard())


@router.message(HomeworkStates.PERSONAL_MENU, F.text == "‚úèÔ∏è –†–µ–¥–∞–∫—Ç–æ—Ä –ª–∏—á–Ω–æ–π –¥–æ–º–∞—à–∫–∏")
async def homework_personal_editor_menu(message: Message, state: FSMContext) -> None:
    await state.set_state(HomeworkStates.PERSONAL_EDITOR_MENU)
    await message.answer(
        "<b>–†–µ–¥–∞–∫—Ç–æ—Ä –ª–∏—á–Ω–æ–π –¥–æ–º–∞—à–∫–∏</b>\n\n"
        "–ó–¥–µ—Å—å –≤—ã –º–æ–∂–µ—Ç–µ –¥–æ–±–∞–≤–∏—Ç—å –Ω–æ–≤–æ–µ –¥–æ–º–∞—à–Ω–µ–µ –∑–∞–¥–∞–Ω–∏–µ, –∏–∑–º–µ–Ω–∏—Ç—å —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–µ –∏–ª–∏ —É–¥–∞–ª–∏—Ç—å –µ–≥–æ.",
        reply_markup=homework_personal_editor_keyboard(),
    )


@router.message(HomeworkStates.PERSONAL_EDITOR_MENU, F.text == "‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –≤ –ª–∏—á–Ω—É—é –¥–æ–º–∞—à–∫—É")
async def homework_personal_editor_back(message: Message, state: FSMContext) -> None:
    await state.set_state(HomeworkStates.PERSONAL_MENU)
    await message.answer("–í—ã –≤–µ—Ä–Ω—É–ª–∏—Å—å –≤ –º–µ–Ω—é –ª–∏—á–Ω–æ–π –¥–æ–º–∞—à–∫–∏.", reply_markup=homework_personal_menu_keyboard())


@router.message(HomeworkStates.PERSONAL_EDITOR_MENU, F.text == "‚ûï –î–æ–±–∞–≤–∏—Ç—å –ª–∏—á–Ω–æ–µ –¥–∑")
async def homework_personal_add_start(message: Message, state: FSMContext) -> None:
    ctx = get_context()
    group_code = await _ensure_group(message)
    if not group_code:
        return
    subjects = await ctx.schedule_service.get_unique_subjects_for_week(group_code, dt.date.today())
    await state.set_state(HomeworkStates.PERSONAL_ADD_SELECT_PAIR)
    await message.answer(
        "üß© <b>–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –ª–∏—á–Ω–æ–≥–æ –¥–∑</b>\n\n"
        "–í—ã–±–µ—Ä–∏—Ç–µ –ø—Ä–µ–¥–º–µ—Ç –∏–∑ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è –∏–ª–∏ –Ω–∞–ø–∏—à–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –≤—Ä—É—á–Ω—É—é:",
        reply_markup=homework_subjects_keyboard(subjects),
    )


@router.callback_query(F.data == "hw_personal_add_cancel")
async def homework_personal_add_cancel(callback: CallbackQuery, state: FSMContext) -> None:
    await state.set_state(HomeworkStates.PERSONAL_EDITOR_MENU)
    await callback.answer("–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –ª–∏—á–Ω–æ–≥–æ –¥–∑ –æ—Ç–º–µ–Ω–µ–Ω–æ.")
    try:
        await callback.message.delete()
    except Exception:
        pass
    await callback.message.answer(
        "–í—ã –≤–µ—Ä–Ω—É–ª–∏—Å—å –≤ —Ä–µ–¥–∞–∫—Ç–æ—Ä –ª–∏—á–Ω–æ–π –¥–æ–º–∞—à–∫–∏.",
        reply_markup=homework_personal_editor_keyboard(),
    )


@router.message(HomeworkStates.PERSONAL_ADD_SELECT_PAIR)
async def homework_personal_add_pair_name(message: Message, state: FSMContext) -> None:
    if message.text == "‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞":
        await state.set_state(HomeworkStates.PERSONAL_EDITOR_MENU)
        await message.answer("–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ.", reply_markup=homework_personal_editor_keyboard())
        return
    subject = (message.text or "").strip()
    if not subject or subject.startswith("/"):
        await message.answer("–ù–∞–∑–≤–∞–Ω–∏–µ –ø–∞—Ä—ã –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.")
        return
    await state.update_data(personal_subject=subject)
    await state.set_state(HomeworkStates.PERSONAL_ADD_WAIT_CONTENT)
    await message.answer(
        f"–í—ã –¥–æ–±–∞–≤–ª—è–µ—Ç–µ –¥–æ–º–∞—à–Ω–µ–µ –∑–∞–¥–∞–Ω–∏–µ –¥–ª—è –ø–∞—Ä—ã: <b>{subject}</b>\n\n"
        "–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ (–µ—Å–ª–∏ –Ω—É–∂–Ω–æ) –∏ —Ç–µ–∫—Å—Ç –∑–∞–¥–∞–Ω–∏—è.\n"
        "–ó–∞–¥–∞–Ω–∏–µ –±—É–¥–µ—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —É–¥–∞–ª–µ–Ω–æ —á–µ—Ä–µ–∑ –Ω–µ–∫–æ—Ç–æ—Ä–æ–µ –≤—Ä–µ–º—è –ø–æ—Å–ª–µ –ø–∞—Ä—ã.",
        reply_markup=homework_personal_cancel_inline(),
    )


@router.message(HomeworkStates.PUBLIC_MENU, F.text == "üëÆ –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –î–ó –≥—Ä—É–ø–ø—ã")
async def homework_public_steward_queue(message: Message, state: FSMContext) -> None:
    ctx = get_context()
    group_code = await _ensure_group(message)
    if not group_code:
        return
    is_steward = await _is_steward_for_group(message, group_code)
    if not is_steward:
        kb = await _public_menu_keyboard_for_user(message)
        await message.answer("–≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ —Å—Ç–∞—Ä–æ—Å—Ç–µ —Å–≤–æ–µ–π –≥—Ä—É–ø–ø—ã.", reply_markup=kb)
        return
    items, total, pages = ctx.homework_service.load_public_pending_page(1)
    group_items = [item for item in items if item.get("group_code") == group_code]
    if not group_items:
        kb = await _public_menu_keyboard_for_user(message)
        await message.answer("–°–µ–π—á–∞—Å –Ω–µ—Ç –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–Ω—ã—Ö –∑–∞–¥–∞–Ω–∏–π –¥–ª—è –≤–∞—à–µ–π –≥—Ä—É–ø–ø—ã.", reply_markup=kb)
        return
    for item in group_items:
        username = item.get("username") or "-"
        subject = item.get("subject") or "-"
        text = item.get("text") or "-"
        ai_raw = item.get("ai_result", {}).get("raw")
        ai_text = ai_raw if ai_raw is not None else "-"
        msg_text = (
            f"–ü—Ä–µ–¥–ª–æ–∂–∏–ª: @{username}\n"
            f"–ì—Ä—É–ø–ø–∞: {group_code}\n"
            f"–ü—Ä–µ–¥–º–µ—Ç: {subject}\n"
            f"–¢–µ–∫—Å—Ç:\n{text}\n\n"
            f"AI:\n{ai_text}"
        )
        await message.answer(msg_text, reply_markup=admin_pending_inline(item["id"]))


@router.message(HomeworkStates.PERSONAL_ADD_WAIT_CONTENT, F.photo)
async def homework_personal_add_photos(message: Message, state: FSMContext) -> None:
    ctx = get_context()
    await message.answer("‚úÖ –§–æ—Ç–æ –ø–æ–ª—É—á–µ–Ω—ã, –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—é...")
    telegraph_url = await ctx.homework_service.upload_images_and_make_telegraph(message)
    data = await state.get_data()
    data["personal_telegraph_url"] = telegraph_url
    await state.update_data(**data)
    await message.answer(
        "‚úÖ –§–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏ –æ–±—Ä–∞–±–æ—Ç–∞–Ω—ã.\n–¢–µ–ø–µ—Ä—å –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –æ–¥–Ω–∏–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º —Ç–µ–∫—Å—Ç –¥–æ–º–∞—à–Ω–µ–≥–æ –∑–∞–¥–∞–Ω–∏—è."
    )


@router.message(HomeworkStates.PERSONAL_ADD_WAIT_CONTENT, F.text)
async def homework_personal_add_text(message: Message, state: FSMContext) -> None:
    if message.text.startswith("/"):
        return
    ctx = get_context()
    data = await state.get_data()
    subject = data.get("personal_subject") or "–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è"
    telegraph_url = data.get("personal_telegraph_url")
    text = message.text.strip()
    ctx.homework_service.add_personal_homework(
        user_id=message.from_user.id,
        subject=subject,
        text=text,
        telegraph_url=telegraph_url,
        delete_at=None,
    )
    await state.update_data(personal_subject=None, personal_telegraph_url=None)
    await state.set_state(HomeworkStates.PERSONAL_MENU)
    await message.answer(
        "‚úÖ –õ–∏—á–Ω–æ–µ –¥–æ–º–∞—à–Ω–µ–µ –∑–∞–¥–∞–Ω–∏–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ.",
        reply_markup=homework_personal_menu_keyboard(),
    )


@router.message(HomeworkStates.PERSONAL_EDITOR_MENU, F.text == "üìÇ –ò–∑–º–µ–Ω–∏—Ç—å/—É–¥–∞–ª–∏—Ç—å –ª–∏—á–Ω–æ–µ –¥–∑")
async def homework_personal_edit_start(message: Message, state: FSMContext) -> None:
    ctx = get_context()
    items = ctx.homework_service._load_personal_hw(message.from_user.id)
    if not items:
        await message.answer(
            "–£ –≤–∞—Å –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –ª–∏—á–Ω—ã—Ö –∑–∞–¥–∞–Ω–∏–π –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è.",
            reply_markup=homework_personal_editor_keyboard()
        )
        return
    unique_subjects = sorted(list(set([i.get("subject") for i in items if i.get("subject")])))
    await state.set_state(HomeworkStates.PERSONAL_EDIT_SELECT_SUBJECT)
    await message.answer(
        "–í—ã–±–µ—Ä–∏—Ç–µ –ø—Ä–µ–¥–º–µ—Ç, –∑–∞–¥–∞–Ω–∏–µ –ø–æ –∫–æ—Ç–æ—Ä–æ–º—É –Ω—É–∂–Ω–æ –∏–∑–º–µ–Ω–∏—Ç—å –∏–ª–∏ —É–¥–∞–ª–∏—Ç—å:",
        reply_markup=homework_subjects_keyboard(unique_subjects)
    )


@router.message(HomeworkStates.PERSONAL_EDIT_SELECT_SUBJECT)
async def homework_personal_edit_subject_select(message: Message, state: FSMContext) -> None:
    if message.text == "‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞":
        await state.set_state(HomeworkStates.PERSONAL_EDITOR_MENU)
        await message.answer("–û—Ç–º–µ–Ω–µ–Ω–æ.", reply_markup=homework_personal_editor_keyboard())
        return
    subject = message.text.strip()
    await state.update_data(edit_subject=subject)
    await state.set_state(HomeworkStates.PERSONAL_EDIT_SELECT_ACTION)
    await message.answer(
        f"–í—ã–±—Ä–∞–Ω–æ: <b>{subject}</b>. –ß—Ç–æ –≤—ã —Ö–æ—Ç–∏—Ç–µ —Å–¥–µ–ª–∞—Ç—å?",
        reply_markup=homework_edit_action_keyboard()
    )


@router.message(HomeworkStates.PERSONAL_EDIT_SELECT_ACTION)
async def homework_personal_edit_action_select(message: Message, state: FSMContext) -> None:
    data = await state.get_data()
    subject = data.get("edit_subject")
    ctx = get_context()
    if message.text == "üóë –£–¥–∞–ª–∏—Ç—å":
        success = await ctx.homework_service.delete_personal_homework(message.from_user.id, subject)
        if success:
            await message.answer(
                f"‚úÖ –ó–∞–¥–∞–Ω–∏—è –ø–æ –ø—Ä–µ–¥–º–µ—Ç—É <b>{subject}</b> —É–¥–∞–ª–µ–Ω—ã.",
                reply_markup=homework_personal_editor_keyboard(),
            )
        else:
            await message.answer(
                "–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è –∏–ª–∏ –∑–∞–¥–∞–Ω–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω—ã.",
                reply_markup=homework_personal_editor_keyboard(),
            )
        await state.set_state(HomeworkStates.PERSONAL_EDITOR_MENU)
    elif message.text == "‚úèÔ∏è –ò–∑–º–µ–Ω–∏—Ç—å —Ç–µ–∫—Å—Ç":
        await state.set_state(HomeworkStates.PERSONAL_EDIT_WAIT_TEXT)
        await message.answer(
            "–û—Ç–ø—Ä–∞–≤—å—Ç–µ –Ω–æ–≤—ã–π —Ç–µ–∫—Å—Ç –¥–ª—è –∑–∞–¥–∞–Ω–∏—è (—Å—Ç–∞—Ä—ã–π –±—É–¥–µ—Ç –ø–µ—Ä–µ–∑–∞–ø–∏—Å–∞–Ω).\n"
            "–§–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏ –æ—Å—Ç–∞–Ω—É—Ç—Å—è –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π."
        )
    else:
        await state.set_state(HomeworkStates.PERSONAL_EDITOR_MENU)
        await message.answer("–î–µ–π—Å—Ç–≤–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ.", reply_markup=homework_personal_editor_keyboard())


@router.message(HomeworkStates.PERSONAL_EDIT_WAIT_TEXT)
async def homework_personal_save_edited_text(message: Message, state: FSMContext) -> None:
    if message.text.startswith("/"):
        return
    data = await state.get_data()
    subject = data.get("edit_subject")
    ctx = get_context()
    items = ctx.homework_service._load_personal_hw(message.from_user.id)
    target_id = None
    for item in items:
        if item.get("subject") == subject:
            target_id = item.get("id")
            break
    if target_id:
        await ctx.homework_service.edit_personal_homework_text(
            message.from_user.id,
            target_id,
            message.text.strip(),
        )
        await message.answer("‚úÖ –¢–µ–∫—Å—Ç –∑–∞–¥–∞–Ω–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω.", reply_markup=homework_personal_editor_keyboard())
    else:
        await message.answer("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ –∑–∞–¥–∞–Ω–∏–µ –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è.", reply_markup=homework_personal_editor_keyboard())
    await state.set_state(HomeworkStates.PERSONAL_EDITOR_MENU)


@router.message(HomeworkStates.PERSONAL_MENU, F.text == "‚è∞ –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ –ª–∏—á–Ω–æ–π –¥–æ–º–∞—à–∫–µ")
async def homework_personal_notify_settings(message: Message, state: FSMContext) -> None:
    ctx = get_context()
    current = await ctx.db.get_homework_notify_minutes(message.from_user.id)
    if current is None:
        current = 24 * 60
    await state.set_state(HomeworkStates.PERSONAL_NOTIFICATIONS_MENU)
    await state.update_data(notify_minutes=current)
    hours = current // 60
    await message.answer(
        "<b>–ù–∞—Å—Ç—Ä–æ–π–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –æ –ª–∏—á–Ω–æ–π –¥–æ–º–∞—à–∫–µ</b>\n\n"
        f"–°–µ–π—á–∞—Å –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è –ø—Ä–∏—Ö–æ–¥—è—Ç –ø—Ä–∏–º–µ—Ä–Ω–æ –∑–∞ <b>{hours}</b> —á –¥–æ –ø–∞—Ä—ã.\n\n"
        "–û—Ç–ø—Ä–∞–≤—å—Ç–µ —á–∏—Å–ª–æ –≤ –º–∏–Ω—É—Ç–∞—Ö, –∑–∞ —Å–∫–æ–ª—å–∫–æ –≤—Ä–µ–º–µ–Ω–∏ –¥–æ –ø–∞—Ä—ã –ø—Ä–∏—Å—ã–ª–∞—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ.\n"
        "–ù–∞–ø—Ä–∏–º–µ—Ä: <code>1440</code> –¥–ª—è 24 —á–∞—Å–æ–≤.",
    )


@router.message(HomeworkStates.PERSONAL_NOTIFICATIONS_MENU)
async def homework_personal_notify_set(message: Message, state: FSMContext) -> None:
    ctx = get_context()
    text = (message.text or "").strip()
    if not text.isdigit():
        await message.answer("–û—Ç–ø—Ä–∞–≤—å—Ç–µ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–µ —á–∏—Å–ª–æ –º–∏–Ω—É—Ç.")
        return
    minutes = int(text)
    if minutes <= 0:
        await message.answer("–ß–∏—Å–ª–æ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –±–æ–ª—å—à–µ –Ω—É–ª—è.")
        return
    await ctx.db.set_homework_notify_minutes(message.from_user.id, minutes)
    hours = minutes // 60
    await state.set_state(HomeworkStates.PERSONAL_MENU)
    await message.answer(
        f"‚úÖ –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –±—É–¥—É—Ç –ø—Ä–∏—Ö–æ–¥–∏—Ç—å –ø—Ä–∏–º–µ—Ä–Ω–æ –∑–∞ <b>{hours}</b> —á –¥–æ –ø–∞—Ä—ã.",
        reply_markup=homework_personal_menu_keyboard(),
    )


@router.message(HomeworkStates.PUBLIC_MENU, F.text == "‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é –¥–æ–º–∞—à–∫–∏")
async def homework_public_back_to_hw_menu(message: Message, state: FSMContext) -> None:
    await state.set_state(HomeworkStates.MENU)
    await message.answer("–í—ã –≤–µ—Ä–Ω—É–ª–∏—Å—å –≤ –º–µ–Ω—é –¥–æ–º–∞—à–∫–∏.", reply_markup=homework_main_keyboard())


@router.message(HomeworkStates.PUBLIC_MENU, F.text == "üîé –ü—Ä–æ—Å–º–æ—Ç—Ä –æ–±—â–µ–≥–æ –¥–∑")
async def homework_public_view(message: Message) -> None:
    ctx = get_context()
    group_code = await _ensure_group(message)
    if not group_code:
        return
    text = await ctx.homework_service.format_public_view(group_code)
    kb = await _public_menu_keyboard_for_user(message)
    await message.answer(text, disable_web_page_preview=True, reply_markup=kb)


@router.message(HomeworkStates.PUBLIC_MENU, F.text == "üìù –ü—Ä–µ–¥–ª–æ–∂–∏—Ç—å –æ–±—â–µ–µ –¥–∑")
async def homework_public_suggest_start(message: Message, state: FSMContext) -> None:
    ctx = get_context()
    group_code = await _ensure_group(message)
    if not group_code:
        return
    subjects = await ctx.schedule_service.get_unique_subjects_for_week(group_code, dt.date.today())
    await state.set_state(HomeworkStates.PUBLIC_SUGGEST_WAIT_PAIR)
    await state.update_data(public_group_code=group_code)
    await message.answer(
        "üìù <b>–ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ –æ–±—â–µ–≥–æ –¥–∑</b>\n\n"
        "–í—ã–±–µ—Ä–∏—Ç–µ –ø—Ä–µ–¥–º–µ—Ç –∏–∑ —Å–ø–∏—Å–∫–∞ –∏–ª–∏ –Ω–∞–ø–∏—à–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –≤—Ä—É—á–Ω—É—é:",
        reply_markup=homework_subjects_keyboard(subjects),
    )


@router.callback_query(F.data == "hw_public_suggest_cancel")
async def homework_public_suggest_cancel(callback: CallbackQuery, state: FSMContext) -> None:
    await state.set_state(HomeworkStates.PUBLIC_MENU)
    await callback.answer("–û—Ç–ø—Ä–∞–≤–∫–∞ –æ–±—â–µ–≥–æ –¥–∑ –æ—Ç–º–µ–Ω–µ–Ω–∞.")
    try:
        await callback.message.delete()
    except Exception:
        pass
    kb = await _public_menu_keyboard_for_user(callback.message)
    await callback.message.answer(
        "–í—ã –≤–µ—Ä–Ω—É–ª–∏—Å—å –≤ –º–µ–Ω—é –æ–±—â–µ–π –¥–æ–º–∞—à–∫–∏.",
        reply_markup=kb,
    )


@router.message(HomeworkStates.PUBLIC_SUGGEST_WAIT_PAIR)
async def homework_public_suggest_pair(message: Message, state: FSMContext) -> None:
    if message.text == "‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞":
        await state.set_state(HomeworkStates.PUBLIC_MENU)
        kb = await _public_menu_keyboard_for_user(message)
        await message.answer("–û—Ç–º–µ–Ω–µ–Ω–æ.", reply_markup=kb)
        return
    subject = (message.text or "").strip()
    if not subject or subject.startswith("/"):
        await message.answer("–ù–∞–∑–≤–∞–Ω–∏–µ –ø–∞—Ä—ã –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.")
        return
    await state.update_data(public_subject=subject)
    await state.set_state(HomeworkStates.PUBLIC_SUGGEST_WAIT_CONTENT)
    await message.answer(
        f"–í—ã –ø—Ä–µ–¥–ª–∞–≥–∞–µ—Ç–µ –æ–±—â–µ–µ –¥–∑ –¥–ª—è –ø–∞—Ä—ã: <b>{subject}</b>\n\n"
        "–°–Ω–∞—á–∞–ª–∞ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏ (–µ—Å–ª–∏ –Ω—É–∂–Ω—ã), –∑–∞—Ç–µ–º —Ç–µ–∫—Å—Ç –¥–æ–º–∞—à–Ω–µ–≥–æ –∑–∞–¥–∞–Ω–∏—è.",
        reply_markup=homework_public_suggest_cancel_inline(),
    )


@router.message(HomeworkStates.PUBLIC_SUGGEST_WAIT_CONTENT, F.photo)
async def homework_public_suggest_photos(message: Message, state: FSMContext) -> None:
    ctx = get_context()
    await message.answer("‚úÖ –§–æ—Ç–æ –ø–æ–ª—É—á–µ–Ω—ã, –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—é...")
    telegraph_url = await ctx.homework_service.upload_images_and_make_telegraph(message)
    data = await state.get_data()
    data["public_telegraph_url"] = telegraph_url
    await state.update_data(**data)
    await message.answer(
        "‚úÖ –§–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏ –æ–±—Ä–∞–±–æ—Ç–∞–Ω—ã.\n–¢–µ–ø–µ—Ä—å –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –æ–¥–Ω–∏–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º —Ç–µ–∫—Å—Ç –¥–æ–º–∞—à–Ω–µ–≥–æ –∑–∞–¥–∞–Ω–∏—è."
    )


@router.message(HomeworkStates.PUBLIC_SUGGEST_WAIT_CONTENT, F.text)
async def homework_public_suggest_text(message: Message, state: FSMContext) -> None:
    if message.text.startswith("/"):
        return
    ctx = get_context()
    data = await state.get_data()
    group_code = data.get("public_group_code")
    subject = data.get("public_subject") or "–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è"
    telegraph_url = data.get("public_telegraph_url")
    text = message.text.strip()
    ai_result = await ctx.homework_service.pollinations_check_homework(text)
    ctx.homework_service.append_ai_log(
        user_id=message.from_user.id,
        username=message.from_user.username,
        full_name=message.from_user.full_name,
        subject=subject,
        text=text,
        telegraph_url=telegraph_url,
        result=ai_result,
    )
    config = ctx.homework_service.load_ai_config()
    auto_accept = config.get("auto_accept", False)
    decision = ai_result.get("decision") or "–Ω–µ—Ç"
    if decision == "–¥–∞" and auto_accept:
        await ctx.homework_service.add_public_homework(
            group_code=group_code,
            subject=subject,
            text=text,
            telegraph_url=telegraph_url,
        )
        await state.update_data(public_group_code=None, public_subject=None, public_telegraph_url=None)
        await state.set_state(HomeworkStates.PUBLIC_MENU)
        kb = await _public_menu_keyboard_for_user(message)
        await message.answer(
            "‚úÖ –î–æ–º–∞—à–∫–∞ –ø—Ä–æ—à–ª–∞ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫—É—é –ø—Ä–æ–≤–µ—Ä–∫—É –∏ –¥–æ–±–∞–≤–ª–µ–Ω–∞ –∫ –æ–±—â–µ–π –¥–æ–º–∞—à–∫–µ –≥—Ä—É–ø–ø—ã.\n\n"
            "–í—ã –º–æ–∂–µ—Ç–µ —É–≤–∏–¥–µ—Ç—å –µ—ë –≤ —Ä–∞–∑–¥–µ–ª–µ ¬´üîé –ü—Ä–æ—Å–º–æ—Ç—Ä –æ–±—â–µ–≥–æ –¥–∑¬ª.",
            reply_markup=kb,
        )
        return
    ctx.homework_service.add_public_pending(
        user_id=message.from_user.id,
        username=message.from_user.username,
        full_name=message.from_user.full_name,
        group_code=group_code,
        subject=subject,
        text=text,
        telegraph_url=telegraph_url,
        ai_result=ai_result,
    )
    await state.update_data(public_group_code=None, public_subject=None, public_telegraph_url=None)
    await state.set_state(HomeworkStates.PUBLIC_MENU)
    kb = await _public_menu_keyboard_for_user(message)
    await message.answer(
        "üìù –ó–∞–¥–∞–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –Ω–∞ –ø—Ä–æ–≤–µ—Ä–∫—É —Å—Ç–∞—Ä–æ—Å—Ç–µ –∏–ª–∏ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.\n\n"
        "–û–∂–∏–¥–∞–π—Ç–µ –æ–¥–æ–±—Ä–µ–Ω–∏—è.",
        reply_markup=kb,
    )

13. app/handlers/schedule.py  (5.4KB, 2025-11-24 22:39:01)
   –†–æ–ª—å: Router ‚Ä¢ Text/UI
   –ò–º–ø–æ—Ä—Ç—ã (–ª–æ–∫–∞–ª—å–Ω—ã–µ): app.core.context, app.core.states, app.keyboards.reply
   –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ—Ç—Å—è –º–æ–¥—É–ª—è–º–∏: app.handlers.__init__
–ö–æ–¥:
import datetime as dt

from aiogram import Router, F
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import StatesGroup, State
from aiogram.types import Message

from app.core.context import get_context
from app.core.states import MenuStates
from app.keyboards.reply import main_menu_keyboard, schedule_keyboard

router = Router()


class ScheduleGroupStates(StatesGroup):
    WAITING_FOR_GROUP = State()


@router.message(MenuStates.SCHEDULE, F.text == "–°–µ–≥–æ–¥–Ω—è")
async def schedule_today(message: Message, state: FSMContext) -> None:
    ctx = get_context()
    user = await ctx.db.get_user(message.from_user.id)
    group_code = user["group_code"] if user else None
    if not group_code:
        await state.set_state(ScheduleGroupStates.WAITING_FOR_GROUP)
        await state.update_data(schedule_mode="day", schedule_offset=0)
        text = (
            "–£ –≤–∞—Å –ø–æ–∫–∞ –Ω–µ —É–∫–∞–∑–∞–Ω–∞ –≥—Ä—É–ø–ø–∞ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é.\n"
            "–û—Ç–ø—Ä–∞–≤—å—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –≥—Ä—É–ø–ø—ã, –¥–ª—è –∫–æ—Ç–æ—Ä–æ–π –Ω—É–∂–Ω–æ –ø–æ–∫–∞–∑–∞—Ç—å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–∞ —Å–µ–≥–æ–¥–Ω—è.\n"
            "–ù–∞–ø—Ä–∏–º–µ—Ä: <b>–ò–°-131</b>.\n\n"
            "–ï—Å–ª–∏ —Ö–æ—Ç–∏—Ç–µ —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –≥—Ä—É–ø–ø—É –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É /setmygroup."
        )
        await message.answer(text)
        return
    today = dt.date.today()
    text = await ctx.schedule_service.get_day_schedule_text(group_code, today)
    await message.answer(text, reply_markup=schedule_keyboard())


@router.message(MenuStates.SCHEDULE, F.text == "–ó–∞–≤—Ç—Ä–∞")
async def schedule_tomorrow(message: Message, state: FSMContext) -> None:
    ctx = get_context()
    user = await ctx.db.get_user(message.from_user.id)
    group_code = user["group_code"] if user else None
    if not group_code:
        await state.set_state(ScheduleGroupStates.WAITING_FOR_GROUP)
        await state.update_data(schedule_mode="day", schedule_offset=1)
        text = (
            "–£ –≤–∞—Å –ø–æ–∫–∞ –Ω–µ —É–∫–∞–∑–∞–Ω–∞ –≥—Ä—É–ø–ø–∞ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é.\n"
            "–û—Ç–ø—Ä–∞–≤—å—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –≥—Ä—É–ø–ø—ã, –¥–ª—è –∫–æ—Ç–æ—Ä–æ–π –Ω—É–∂–Ω–æ –ø–æ–∫–∞–∑–∞—Ç—å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–∞ –∑–∞–≤—Ç—Ä–∞.\n"
            "–ù–∞–ø—Ä–∏–º–µ—Ä: <b>–ò–°-131</b>.\n\n"
            "–ï—Å–ª–∏ —Ö–æ—Ç–∏—Ç–µ —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –≥—Ä—É–ø–ø—É –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É /setmygroup."
        )
        await message.answer(text)
        return
    tomorrow = dt.date.today() + dt.timedelta(days=1)
    text = await ctx.schedule_service.get_day_schedule_text(group_code, tomorrow)
    await message.answer(text, reply_markup=schedule_keyboard())


@router.message(MenuStates.SCHEDULE, F.text == "–ù–∞ –≤—Å—é –Ω–µ–¥–µ–ª—é")
async def schedule_week(message: Message, state: FSMContext) -> None:
    ctx = get_context()
    user = await ctx.db.get_user(message.from_user.id)
    group_code = user["group_code"] if user else None
    if not group_code:
        await state.set_state(ScheduleGroupStates.WAITING_FOR_GROUP)
        await state.update_data(schedule_mode="week", schedule_offset=0)
        text = (
            "–£ –≤–∞—Å –ø–æ–∫–∞ –Ω–µ —É–∫–∞–∑–∞–Ω–∞ –≥—Ä—É–ø–ø–∞ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é.\n"
            "–û—Ç–ø—Ä–∞–≤—å—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –≥—Ä—É–ø–ø—ã, –¥–ª—è –∫–æ—Ç–æ—Ä–æ–π –Ω—É–∂–Ω–æ –ø–æ–∫–∞–∑–∞—Ç—å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–∞ –Ω–µ–¥–µ–ª—é.\n"
            "–ù–∞–ø—Ä–∏–º–µ—Ä: <b>–ò–°-131</b>.\n\n"
            "–ï—Å–ª–∏ —Ö–æ—Ç–∏—Ç–µ —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –≥—Ä—É–ø–ø—É –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É /setmygroup."
        )
        await message.answer(text)
        return
    today = dt.date.today()
    text = await ctx.schedule_service.get_week_schedule_text(group_code, today)
    await message.answer(text, reply_markup=schedule_keyboard())


@router.message(ScheduleGroupStates.WAITING_FOR_GROUP)
async def schedule_temp_group_input(message: Message, state: FSMContext) -> None:
    text_raw = message.text or ""
    if text_raw == "–í—ã–π—Ç–∏ –Ω–∞–∑–∞–¥":
        await state.set_state(MenuStates.MAIN)
        await message.answer("–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é –ù–ú–ö –ü–æ–º–æ—â–Ω–∏–∫–∞.", reply_markup=main_menu_keyboard())
        return
    if text_raw.startswith("/"):
        return
    ctx = get_context()
    raw_group = text_raw.strip()
    canonical = ctx.group_resolver.resolve(raw_group)
    if not canonical:
        await message.answer(
            "–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å —Ç–∞–∫—É—é –≥—Ä—É–ø–ø—É. –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ –≥—Ä—É–ø–ø–∞ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –∏ –Ω–∞–ø–∏—Å–∞–Ω–∞ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ, –∑–∞—Ç–µ–º –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –µ—ë –µ—â—ë —Ä–∞–∑."
        )
        return
    data = await state.get_data()
    mode = data.get("schedule_mode") or "day"
    offset = int(data.get("schedule_offset", 0))
    today = dt.date.today()
    target_date = today + dt.timedelta(days=offset)
    if mode == "week":
        text = await ctx.schedule_service.get_week_schedule_text(canonical, target_date)
    else:
        text = await ctx.schedule_service.get_day_schedule_text(canonical, target_date)
    await state.set_state(MenuStates.SCHEDULE)
    await message.answer(text, reply_markup=schedule_keyboard())


@router.message(MenuStates.SCHEDULE, F.text == "–í—ã–π—Ç–∏ –Ω–∞–∑–∞–¥")
async def schedule_back(message: Message, state: FSMContext) -> None:
    await state.set_state(MenuStates.MAIN)
    text = "–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é –ù–ú–ö –ü–æ–º–æ—â–Ω–∏–∫–∞."
    await message.answer(text, reply_markup=main_menu_keyboard())

14. app/handlers/start.py  (9.3KB, 2025-11-24 23:40:03)
   –†–æ–ª—å: Router ‚Ä¢ Text/UI
   –ò–º–ø–æ—Ä—Ç—ã (–ª–æ–∫–∞–ª—å–Ω—ã–µ): app.core.commands, app.core.constants, app.core.context, app.core.states, app.keyboards.inline, app.keyboards.reply
   –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ—Ç—Å—è –º–æ–¥—É–ª—è–º–∏: app.core.bot, app.handlers.__init__
–ö–æ–¥:
from html import escape
import datetime as dt
import json
import traceback
from pathlib import Path

from aiogram import Router, BaseMiddleware
from aiogram.filters import CommandStart
from aiogram.fsm.context import FSMContext
from aiogram.types import Message, CallbackQuery, BotCommandScopeChat

from app.core.commands import get_admin_bot_commands, get_default_bot_commands
from app.core.constants import TOS_URL
from app.core.context import get_context
from app.core.states import MenuStates
from app.keyboards.inline import tos_keyboard
from app.keyboards.reply import main_menu_keyboard

router = Router()

BASE_DIR = Path(__file__).resolve().parents[2]
USER_ERRORS_LOG_PATH = BASE_DIR / "config" / "user_errors.log"
ADMIN_LOGS_USER_ID = 8189336411


def build_tos_message_text(from_user) -> str:
    nickname = escape(from_user.full_name or from_user.username or "–¥—Ä—É–≥")
    text = (
        f"–ü—Ä–∏–≤–µ—Ç, {nickname}!\n\n"
        f"–ò—Å–ø–æ–ª—å–∑—É—è —Å–µ—Ä–≤–∏—Å <b>–ù–ú–ö –ü–æ–º–æ—â–Ω–∏–∫</b>, –≤—ã –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–∞–µ—Ç–µ —Å–æ–≥–ª–∞—Å–∏–µ —Å "
        f"<a href=\"{TOS_URL}\">—É—Å–ª–æ–≤–∏—è–º–∏ –ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è</a>.\n\n"
        f"–ù–∞–∂–º–∏—Ç–µ ¬´–û–∫, –ø–æ–Ω—è—Ç–Ω–æ¬ª, —á—Ç–æ–±—ã –æ—Ç–∫—Ä—ã—Ç—å –º–µ–Ω—é."
    )
    return text


class TosMiddleware(BaseMiddleware):
    async def _log_error(self, event, from_user, error: Exception) -> None:
        try:
            user_id = getattr(from_user, "id", None) if from_user else None
            username = getattr(from_user, "username", None) if from_user else None
            chat = getattr(event, "chat", None)
            chat_id = getattr(chat, "id", None) if chat else None
            if isinstance(event, Message):
                payload = event.text or event.caption or ""
            elif isinstance(event, CallbackQuery):
                payload = event.data or ""
            else:
                payload = ""
            tb_text = traceback.format_exc()
            entry = {
                "timestamp": dt.datetime.utcnow().isoformat(),
                "user_id": user_id,
                "chat_id": chat_id,
                "username": username,
                "action": payload,
                "error": str(error),
                "traceback": tb_text,
            }
            USER_ERRORS_LOG_PATH.parent.mkdir(parents=True, exist_ok=True)
            with USER_ERRORS_LOG_PATH.open("a", encoding="utf-8") as f:
                f.write(json.dumps(entry, ensure_ascii=False) + "\n")
            try:
                bot = getattr(event, "bot", None)
                if bot is None and isinstance(event, CallbackQuery):
                    bot = event.message.bot if event.message else None
                if bot is not None:
                    parts = []
                    parts.append("‚ö†Ô∏è –û—à–∏–±–∫–∞ –≤ –±–æ—Ç–µ")
                    parts.append(f"–í—Ä–µ–º—è (UTC): {entry['timestamp']}")
                    if user_id is not None:
                        parts.append(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: {user_id} @{username}" if username else f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: {user_id}")
                    if chat_id is not None:
                        parts.append(f"–ß–∞—Ç: {chat_id}")
                    if payload:
                        parts.append(f"–î–µ–π—Å—Ç–≤–∏–µ: {payload}")
                    parts.append("")
                    parts.append(f"–û—à–∏–±–∫–∞: {str(error)}")
                    parts.append("")
                    parts.append("Traceback:")
                    parts.append(tb_text)
                    text = "\n".join(parts)
                    max_len = 4000
                    if len(text) <= max_len:
                        await bot.send_message(ADMIN_LOGS_USER_ID, f"<pre>{escape(text)}</pre>", disable_web_page_preview=True)
                    else:
                        tmp_dir = BASE_DIR / "config" / "tmp_logs"
                        tmp_dir.mkdir(parents=True, exist_ok=True)
                        file_name = f"error_{dt.datetime.utcnow().strftime('%Y%m%d_%H%M%S_%f')}.log"
                        file_path = tmp_dir / file_name
                        try:
                            with file_path.open("w", encoding="utf-8") as f:
                                f.write(text)
                            from aiogram.types import FSInputFile
                            doc = FSInputFile(str(file_path))
                            await bot.send_document(
                                ADMIN_LOGS_USER_ID,
                                document=doc,
                                caption="‚ö†Ô∏è –û—à–∏–±–∫–∞ –≤ –±–æ—Ç–µ (–ø–æ–ª–Ω—ã–π –ª–æ–≥).",
                            )
                        finally:
                            try:
                                if file_path.exists():
                                    file_path.unlink()
                            except Exception:
                                pass
            except Exception:
                pass
        except Exception:
            pass

    async def _process(self, handler, event, data, from_user):
        if from_user is None:
            return await handler(event, data)
        ctx = get_context()
        ban_entry = await ctx.db.get_ban_for_user(
            from_user.id,
            getattr(from_user, "username", None),
        )
        if ban_entry:
            reason = ban_entry.get("reason") or "–Ω–µ —É–∫–∞–∑–∞–Ω–∞"
            text = (
                "üö´ <b>–î–æ—Å—Ç—É–ø –∫ –±–æ—Ç—É –æ–≥—Ä–∞–Ω–∏—á–µ–Ω.</b>\n\n"
                "–í–∞—à –∞–∫–∫–∞—É–Ω—Ç –±—ã–ª –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω.\n"
                f"–ü—Ä–∏—á–∏–Ω–∞ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏: <b>{escape(str(reason))}</b>\n\n"
                "–ï—Å–ª–∏ –≤—ã —Å—á–∏—Ç–∞–µ—Ç–µ, —á—Ç–æ —ç—Ç–æ –æ—à–∏–±–∫–∞, –Ω–∞–ø–∏—à–∏—Ç–µ "
                '<a href="https://t.me/Light_YYagami">–∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ü–∏–∏</a>.'
            )
            if isinstance(event, Message):
                await event.answer(text, disable_web_page_preview=True)
            elif isinstance(event, CallbackQuery) and event.message:
                await event.message.answer(text, disable_web_page_preview=True)
                await event.answer()
            return
        user = await ctx.db.get_user(from_user.id)
        if user and user.get("tos_accepted"):
            return await handler(event, data)
        if isinstance(event, Message):
            text = event.text or ""
            if text.startswith("/start"):
                return await handler(event, data)
        if isinstance(event, CallbackQuery) and event.data == "tos_accept":
            return await handler(event, data)
        if not user:
            await ctx.db.ensure_user(
                tg_id=from_user.id,
                username=getattr(from_user, "username", None),
                first_name=getattr(from_user, "first_name", None),
                last_name=getattr(from_user, "last_name", None),
            )
        text = build_tos_message_text(from_user)
        if isinstance(event, Message):
            await event.answer(text, reply_markup=tos_keyboard(), disable_web_page_preview=True)
        elif isinstance(event, CallbackQuery) and event.message:
            await event.message.answer(text, reply_markup=tos_keyboard(), disable_web_page_preview=True)
        return

    async def __call__(self, handler, event, data):
        from_user = getattr(event, "from_user", None)
        try:
            return await self._process(handler, event, data, from_user)
        except Exception as e:
            await self._log_error(event, from_user, e)
            raise


@router.message(CommandStart())
async def cmd_start(message: Message, state: FSMContext) -> None:
    await state.clear()
    ctx = get_context()
    admin_session = await ctx.db.get_active_admin_session_for_user(message.from_user.id)
    if admin_session:
        await message.bot.set_my_commands(
            get_admin_bot_commands(admin_session["level"]),
            scope=BotCommandScopeChat(chat_id=message.chat.id),
        )
    else:
        await message.bot.set_my_commands(
            get_default_bot_commands(),
            scope=BotCommandScopeChat(chat_id=message.chat.id),
        )
    user = await ctx.db.get_user(message.from_user.id)
    if user and user["tos_accepted"]:
        await state.set_state(MenuStates.MAIN)
        text = "–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é –ù–ú–ö –ü–æ–º–æ—â–Ω–∏–∫–∞."
        await message.answer(text, reply_markup=main_menu_keyboard())
        return
    if not user:
        await ctx.db.ensure_user(
            tg_id=message.from_user.id,
            username=message.from_user.username,
            first_name=message.from_user.first_name,
            last_name=message.from_user.last_name,
        )
    text = build_tos_message_text(message.from_user)
    await message.answer(text, reply_markup=tos_keyboard(), disable_web_page_preview=True)


@router.callback_query(lambda c: c.data == "tos_accept")
async def tos_accept(callback: CallbackQuery, state: FSMContext) -> None:
    ctx = get_context()
    await ctx.db.accept_tos(
        tg_id=callback.from_user.id,
        username=callback.from_user.username,
        first_name=callback.from_user.first_name,
        last_name=callback.from_user.last_name,
    )
    await callback.answer()
    await callback.message.edit_text("–°–æ–≥–ª–∞—Å–∏–µ —Å —É—Å–ª–æ–≤–∏—è–º–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –ø–æ–ª—É—á–µ–Ω–æ.")
    await state.set_state(MenuStates.MAIN)
    await callback.message.answer("–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é.", reply_markup=main_menu_keyboard())

15. app/keyboards/admin.py  (8.0KB, 2025-11-24 00:49:54)
   –†–æ–ª—å: UI helper
   –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ—Ç—Å—è –º–æ–¥—É–ª—è–º–∏: app.handlers.__init__, app.handlers.admin, app.handlers.common, app.handlers.homework
–ö–æ–¥:
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton, InlineKeyboardMarkup, InlineKeyboardButton


def admin_main_keyboard(level: int) -> ReplyKeyboardMarkup:
    rows: list[list[KeyboardButton]] = []
    rows.append(
        [
            KeyboardButton(text="üß© –°–∏—Å—Ç–µ–º–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π"),
            KeyboardButton(text="üìä –õ–æ–≥–∏ –∏ —Å—Ç–∞—Ç—É—Å"),
        ]
    )
    if level >= 2:
        rows.append([KeyboardButton(text="üìö –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –¥–æ–º–∞—à–∫–æ–π")])
        rows.append(
            [
                KeyboardButton(text="üìÖ –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ–º"),
                KeyboardButton(text="üì¢ –†–∞—Å—Å—ã–ª–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π"),
            ]
        )
        rows.append(
            [
                KeyboardButton(text="üö´ –ë–∞–Ω / –†–∞–∑–±–∞–Ω"),
                KeyboardButton(text="‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –∫–∞—Ç–µ–≥–æ—Ä–∏–π"),
            ]
        )
        rows.append(
            [
                KeyboardButton(text="‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Ä–∞—Å—Å—ã–ª–∫–∏"),
                KeyboardButton(text="‚èèÔ∏è –í—ã–π—Ç–∏ –∏–∑ –ø–∞–Ω–µ–ª–∏"),
            ]
        )
    else:
        rows.append(
            [
                KeyboardButton(text="‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Ä–∞—Å—Å—ã–ª–∫–∏"),
                KeyboardButton(text="‚èèÔ∏è –í—ã–π—Ç–∏ –∏–∑ –ø–∞–Ω–µ–ª–∏"),
            ]
        )
    return ReplyKeyboardMarkup(keyboard=rows, resize_keyboard=True)


def admin_user_system_keyboard(level: int) -> ReplyKeyboardMarkup:
    keyboard: list[list[KeyboardButton]] = [
        [KeyboardButton(text="üë• –°–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π")],
        [KeyboardButton(text="üîç –ü–æ–∏—Å–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è")],
    ]
    if level >= 3:
        keyboard.append([KeyboardButton(text="üßë‚Äçüíª –°–µ—Å—Å–∏–∏ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–≤")])
    keyboard.append([KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –≤ –∞–¥–º–∏–Ω-–º–µ–Ω—é")])
    return ReplyKeyboardMarkup(keyboard=keyboard, resize_keyboard=True)


def admin_homework_menu_keyboard() -> ReplyKeyboardMarkup:
    return ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text="‚è≥ –û—á–µ—Ä–µ–¥—å –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–Ω—ã—Ö –î–ó")],
            [KeyboardButton(text="üß† AI –ù–∞—Å—Ç—Ä–æ–π–∫–∏")],
            [KeyboardButton(text="üëÆ –°—Ç–∞—Ä–æ—Å—Ç—ã")],
            [KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –≤ –∞–¥–º–∏–Ω-–º–µ–Ω—é")],
        ],
        resize_keyboard=True,
    )


def admin_ai_settings_keyboard(auto_accept: bool) -> ReplyKeyboardMarkup:
    auto_text = "‚úÖ –ê–≤—Ç–æ-–ø—Ä–∏–Ω—è—Ç–∏–µ –í–ö–õ" if auto_accept else "‚õî –ê–≤—Ç–æ-–ø—Ä–∏–Ω—è—Ç–∏–µ –í–´–ö–õ"
    return ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text="üîÑ –û–±–Ω–æ–≤–∏—Ç—å —Å–ø–∏—Å–æ–∫ –º–æ–¥–µ–ª–µ–π"), KeyboardButton(text="ü§ñ –í—ã–±—Ä–∞—Ç—å –º–æ–¥–µ–ª—å")],
            [KeyboardButton(text="üìù –°–∏—Å—Ç–µ–º–Ω—ã–π –ø—Ä–æ–º—Ç"), KeyboardButton(text=auto_text)],
            [KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –≤ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –¥–æ–º–∞—à–∫–æ–π")],
        ],
        resize_keyboard=True,
    )


def admin_stewards_keyboard() -> ReplyKeyboardMarkup:
    return ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text="‚ûï –ù–∞–∑–Ω–∞—á–∏—Ç—å —Å—Ç–∞—Ä–æ—Å—Ç—É"), KeyboardButton(text="‚ûñ –°–Ω—è—Ç—å —Å—Ç–∞—Ä–æ—Å—Ç—É")],
            [KeyboardButton(text="üìã –°–ø–∏—Å–æ–∫ —Å—Ç–∞—Ä–æ—Å—Ç")],
            [KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –≤ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –¥–æ–º–∞—à–∫–æ–π")],
        ],
        resize_keyboard=True,
    )


def admin_pending_inline(req_id: str) -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(
        inline_keyboard=[
            [
                InlineKeyboardButton(text="‚úÖ –û–¥–æ–±—Ä–∏—Ç—å", callback_data=f"hw_apr:{req_id}"),
                InlineKeyboardButton(text="‚ùå –û—Ç–∫–ª–æ–Ω–∏—Ç—å", callback_data=f"hw_rej:{req_id}"),
            ]
        ]
    )


def admin_models_inline(models: list[str]) -> InlineKeyboardMarkup:
    rows = []
    for m in models:
        rows.append([InlineKeyboardButton(text=m, callback_data=f"ai_model:{m}")])
    return InlineKeyboardMarkup(inline_keyboard=rows)


def admin_users_inline_keyboard(page: int, total_pages: int) -> InlineKeyboardMarkup:
    if total_pages < 1:
        total_pages = 1
    if page < 1:
        page = 1
    if page > total_pages:
        page = total_pages
    return InlineKeyboardMarkup(
        inline_keyboard=[
            [
                InlineKeyboardButton(text="‚¨ÖÔ∏è", callback_data=f"admin_users_prev:{page}"),
                InlineKeyboardButton(text=f"üìÑ {page}/{total_pages}", callback_data=f"admin_users_info:{page}"),
                InlineKeyboardButton(text="‚û°Ô∏è", callback_data=f"admin_users_next:{page}"),
            ]
        ]
    )


def admin_sessions_keyboard(sessions: list[dict]) -> InlineKeyboardMarkup:
    rows: list[list[InlineKeyboardButton]] = []
    for s in sessions:
        username = s.get("username") or ""
        if username:
            username_text = f"@{username}"
        else:
            username_text = f"ID {s.get('tg_id')}"
        level = s.get("level", 0)
        text = f"‚ùå {username_text} (lvl {level})"
        if len(text) > 64:
            text = text[:61] + "..."
        rows.append(
            [
                InlineKeyboardButton(
                    text=text,
                    callback_data=f"admin_kill_session:{s['id']}",
                )
            ]
        )
    if rows:
        rows.append(
            [
                InlineKeyboardButton(
                    text="üîÑ –û–±–Ω–æ–≤–∏—Ç—å",
                    callback_data="admin_sessions_refresh",
                )
            ]
        )
    else:
        rows.append(
            [
                InlineKeyboardButton(
                    text="üîÑ –û–±–Ω–æ–≤–∏—Ç—å —Å–ø–∏—Å–æ–∫",
                    callback_data="admin_sessions_refresh",
                )
            ]
        )
    return InlineKeyboardMarkup(inline_keyboard=rows)


def admin_schedule_keyboard() -> ReplyKeyboardMarkup:
    keyboard = [
        [KeyboardButton(text="üîÑ –ü–µ—Ä–µ–ø–∞—Ä—Å–∏—Ç—å —Ç–µ–∫—É—â–µ–µ")],
        [KeyboardButton(text="üóë –£–¥–∞–ª–∏—Ç—å —Å—Ç–∞—Ä—ã–µ —Ñ–∞–π–ª—ã")],
        [KeyboardButton(text="üìã –ü—Ä–æ—Å–º–æ—Ç—Ä–µ—Ç—å –∞–∫—Ç–∏–≤–Ω—ã–µ –ø–æ–¥–ø–∏—Å–∫–∏")],
        [KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –≤ –∞–¥–º–∏–Ω-–º–µ–Ω—é")],
    ]
    return ReplyKeyboardMarkup(keyboard=keyboard, resize_keyboard=True)


def admin_logs_keyboard() -> ReplyKeyboardMarkup:
    keyboard = [
        [KeyboardButton(text="‚è±Ô∏è –ü–æ–∫–∞–∑–∞—Ç—å uptime")],
        [KeyboardButton(text="üìú –ü–æ–∫–∞–∑–∞—Ç—å –ø–æ—Å–ª–µ–¥–Ω–∏–µ N —Å—Ç—Ä–æ–∫ –ª–æ–≥–æ–≤")],
        [KeyboardButton(text="üß† –ü–∞–º—è—Ç—å –∏ CPU")],
        [KeyboardButton(text="üì• –°–∫–∞—á–∞—Ç—å –≤–µ—Å—å –ª–æ–≥")],
        [KeyboardButton(text="üßë‚Äçüíª –õ–æ–≥–∏ –æ—à–∏–±–æ–∫ –ª—é–¥–µ–π")],
        [KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –≤ –∞–¥–º–∏–Ω-–º–µ–Ω—é")],
    ]
    return ReplyKeyboardMarkup(keyboard=keyboard, resize_keyboard=True)


def admin_ban_keyboard() -> ReplyKeyboardMarkup:
    keyboard = [
        [KeyboardButton(text="üö´ –ë–∞–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è")],
        [KeyboardButton(text="‚úÖ –†–∞–∑–±–∞–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è")],
        [KeyboardButton(text="üìã –°–ø–∏—Å–æ–∫ –∑–∞–±–∞–Ω–µ–Ω–Ω—ã—Ö")],
        [KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –≤ –∞–¥–º–∏–Ω-–º–µ–Ω—é")],
    ]
    return ReplyKeyboardMarkup(keyboard=keyboard, resize_keyboard=True)


def admin_mailing_keyboard() -> ReplyKeyboardMarkup:
    keyboard = [
        [KeyboardButton(text="üö´ –û—Ç–∫–ª—é—á–∏—Ç—å —Ä–∞—Å—Å—ã–ª–∫—É –¥–ª—è ID/@username")],
        [KeyboardButton(text="‚úÖ –í–∫–ª—é—á–∏—Ç—å –æ–±—Ä–∞—Ç–Ω–æ ID/@username")],
        [KeyboardButton(text="üìã –ü–æ–∫–∞–∑–∞—Ç—å –∏—Å–∫–ª—é—á–µ–Ω–∏—è")],
        [KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –≤ –∞–¥–º–∏–Ω-–º–µ–Ω—é")],
    ]
    return ReplyKeyboardMarkup(keyboard=keyboard, resize_keyboard=True)

16. app/keyboards/homework.py  (4.8KB, 2025-11-24 23:39:05)
   –†–æ–ª—å: UI helper
   –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ—Ç—Å—è –º–æ–¥—É–ª—è–º–∏: app.handlers.__init__, app.handlers.homework
–ö–æ–¥:
from aiogram.types import (
    ReplyKeyboardMarkup,
    KeyboardButton,
    InlineKeyboardMarkup,
    InlineKeyboardButton,
)


def homework_main_keyboard() -> ReplyKeyboardMarkup:
    return ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text="üìò –õ–∏—á–Ω–∞—è –¥–æ–º–∞—à–∫–∞"), KeyboardButton(text="üìö –û–±—â–∞—è –¥–æ–º–∞—à–∫–∞")],
            [KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é")],
        ],
        resize_keyboard=True,
    )


def homework_personal_menu_keyboard() -> ReplyKeyboardMarkup:
    return ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text="üîé –ü—Ä–æ—Å–º–æ—Ç—Ä –ª–∏—á–Ω–æ–π –¥–æ–º–∞—à–∫–∏")],
            [KeyboardButton(text="‚úèÔ∏è –†–µ–¥–∞–∫—Ç–æ—Ä –ª–∏—á–Ω–æ–π –¥–æ–º–∞—à–∫–∏")],
            [KeyboardButton(text="‚è∞ –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ –ª–∏—á–Ω–æ–π –¥–æ–º–∞—à–∫–µ")],
            [KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é –¥–æ–º–∞—à–∫–∏")],
        ],
        resize_keyboard=True,
    )


def homework_personal_editor_keyboard() -> ReplyKeyboardMarkup:
    return ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å –ª–∏—á–Ω–æ–µ –¥–∑")],
            [KeyboardButton(text="üìÇ –ò–∑–º–µ–Ω–∏—Ç—å/—É–¥–∞–ª–∏—Ç—å –ª–∏—á–Ω–æ–µ –¥–∑")],
            [KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –≤ –ª–∏—á–Ω—É—é –¥–æ–º–∞—à–∫—É")],
        ],
        resize_keyboard=True,
    )


def homework_subjects_keyboard(subjects: list[str]) -> ReplyKeyboardMarkup:
    rows: list[list[KeyboardButton]] = []
    for s in subjects:
        if s:
            rows.append([KeyboardButton(text=str(s))])
    rows.append([KeyboardButton(text="‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞")])
    return ReplyKeyboardMarkup(keyboard=rows, resize_keyboard=True)


def homework_edit_action_keyboard() -> ReplyKeyboardMarkup:
    return ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text="‚úèÔ∏è –ò–∑–º–µ–Ω–∏—Ç—å —Ç–µ–∫—Å—Ç"), KeyboardButton(text="üóë –£–¥–∞–ª–∏—Ç—å")],
            [KeyboardButton(text="‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞")],
        ],
        resize_keyboard=True,
    )


def homework_personal_cancel_inline() -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(
        inline_keyboard=[
            [InlineKeyboardButton(text="‚ùå –û—Ç–º–µ–Ω–∏—Ç—å –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ", callback_data="hw_personal_add_cancel")]
        ]
    )


def homework_public_menu_keyboard(is_steward: bool) -> ReplyKeyboardMarkup:
    if is_steward:
        return ReplyKeyboardMarkup(
            keyboard=[
                [KeyboardButton(text="üìù –ü—Ä–µ–¥–ª–æ–∂–∏—Ç—å –æ–±—â–µ–µ –¥–∑")],
                [KeyboardButton(text="üîé –ü—Ä–æ—Å–º–æ—Ç—Ä –æ–±—â–µ–≥–æ –¥–∑")],
                [KeyboardButton(text="üëÆ –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –î–ó –≥—Ä—É–ø–ø—ã")],
                [KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é –¥–æ–º–∞—à–∫–∏")],
            ],
            resize_keyboard=True,
        )
    return ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text="üìù –ü—Ä–µ–¥–ª–æ–∂–∏—Ç—å –æ–±—â–µ–µ –¥–∑")],
            [KeyboardButton(text="üîé –ü—Ä–æ—Å–º–æ—Ç—Ä –æ–±—â–µ–≥–æ –¥–∑")],
            [KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é –¥–æ–º–∞—à–∫–∏")],
        ],
        resize_keyboard=True,
    )


def homework_public_suggest_cancel_inline() -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(
        inline_keyboard=[
            [InlineKeyboardButton(text="‚ùå –û—Ç–º–µ–Ω–∏—Ç—å –æ—Ç–ø—Ä–∞–≤–∫—É", callback_data="hw_public_suggest_cancel")]
        ]
    )


def homework_public_steward_menu_keyboard() -> ReplyKeyboardMarkup:
    return ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å –æ–±—â–µ–µ –¥–∑")],
            [KeyboardButton(text="üóë –£–¥–∞–ª–∏—Ç—å –æ–±—â–µ–µ –¥–∑")],
            [KeyboardButton(text="‚è≥ –û—á–µ—Ä–µ–¥—å –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–Ω—ã—Ö –¥–∑")],
            [KeyboardButton(text="üîé –ü—Ä–æ—Å–º–æ—Ç—Ä –æ–±—â–µ–≥–æ –¥–∑")],
            [KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é –¥–æ–º–∞—à–∫–∏")],
        ],
        resize_keyboard=True,
    )


def homework_public_pending_inline(req_id: str) -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(
        inline_keyboard=[
            [
                InlineKeyboardButton(text="‚úÖ –û–¥–æ–±—Ä–∏—Ç—å", callback_data=f"hw_public_apr:{req_id}"),
                InlineKeyboardButton(text="‚ùå –û—Ç–∫–ª–æ–Ω–∏—Ç—å", callback_data=f"hw_public_rej:{req_id}"),
            ]
        ]
    )


def homework_public_manage_inline(hw_id: str) -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(
        inline_keyboard=[
            [InlineKeyboardButton(text="üóë –£–¥–∞–ª–∏—Ç—å", callback_data=f"hw_public_del:{hw_id}")]
        ]
    )

17. app/keyboards/inline.py  (811B, 2025-11-23 02:42:59)
   –†–æ–ª—å: UI helper
   –ò–º–ø–æ—Ä—Ç—ã (–ª–æ–∫–∞–ª—å–Ω—ã–µ): app.core.constants
   –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ—Ç—Å—è –º–æ–¥—É–ª—è–º–∏: app.handlers.admin, app.handlers.start
–ö–æ–¥:
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton

from app.core.constants import TOS_URL


def tos_keyboard() -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(
        inline_keyboard=[
            [
                InlineKeyboardButton(text="üìÉ–£—Å–ª–æ–≤–∏—è –ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è", url=TOS_URL),
            ],
            [
                InlineKeyboardButton(text="–û–∫, –ø—Ä–∏–Ω—è—Ç—å‚úÖ", callback_data="tos_accept"),
            ],
        ]
    )


def broadcast_cancel_inline_keyboard() -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(
        inline_keyboard=[
            [
                InlineKeyboardButton(
                    text="‚ùå –û—Ç–º–µ–Ω–∞",
                    callback_data="broadcast_cancel",
                )
            ]
        ]
    )

18. app/keyboards/reply.py  (1.9KB, 2025-11-25 19:42:11)
   –†–æ–ª—å: UI helper
   –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ—Ç—Å—è –º–æ–¥—É–ª—è–º–∏: app.handlers.admin, app.handlers.common, app.handlers.homework, app.handlers.schedule, app.handlers.start
–ö–æ–¥:
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton


def main_menu_keyboard() -> ReplyKeyboardMarkup:
    return ReplyKeyboardMarkup(
        keyboard=[
            [
                KeyboardButton(text="–†–∞—Å–ø–∏—Å–∞–Ω–∏–µüìã"),
                KeyboardButton(text="–î–æ–º–∞—à–∫–∞üìö"),
            ],
            [
                KeyboardButton(text="–õ–∏—á–Ω—ã–π –∫–∞–±–∏–Ω–µ—Çüë§"),
            ],
        ],
        resize_keyboard=True,
    )


def schedule_keyboard() -> ReplyKeyboardMarkup:
    return ReplyKeyboardMarkup(
        keyboard=[
            [
                KeyboardButton(text="–°–µ–≥–æ–¥–Ω—è"),
                KeyboardButton(text="–ó–∞–≤—Ç—Ä–∞"),
            ],
            [
                KeyboardButton(text="–ù–∞ –≤—Å—é –Ω–µ–¥–µ–ª—é"),
            ],
            [
                KeyboardButton(text="–í—ã–π—Ç–∏ –Ω–∞–∑–∞–¥"),
            ],
        ],
        resize_keyboard=True,
    )


def personal_cabinet_keyboard() -> ReplyKeyboardMarkup:
    return ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text="–ü—Ä–µ–º–∏—É–º")],
            [KeyboardButton(text="–ù–∞—Å—Ç—Ä–æ–π–∫–∏")],
            [KeyboardButton(text="‚¨ÖÔ∏è –í—ã–π—Ç–∏ –Ω–∞–∑–∞–¥")],
        ],
        resize_keyboard=True,
    )


def personal_settings_keyboard(has_group: bool, notify_enabled: bool) -> ReplyKeyboardMarkup:
    group_button = "–ò–∑–º–µ–Ω–∏—Ç—å –≥—Ä—É–ø–ø—É" if has_group else "–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –≥—Ä—É–ø–ø—É"
    notify_button = "–£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–∏: –í–∫–ª" if notify_enabled else "–£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–∏: –í—ã–∫–ª"
    return ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text=group_button)],
            [KeyboardButton(text=notify_button)],
            [KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –≤ –ª–∏—á–Ω—ã–π –∫–∞–±–∏–Ω–µ—Ç")],
        ],
        resize_keyboard=True,
    )

19. app/services/admin_service.py  (1.2KB, 2025-11-23 00:23:29)
   –†–æ–ª—å: Service
   –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ—Ç—Å—è –º–æ–¥—É–ª—è–º–∏: app.core.bot
–ö–æ–¥:
import json
from pathlib import Path


class AdminPasswordService:
    def __init__(self, path: Path):
        self.path = path
        self._passwords: dict[str, int] = {}
        self._load()

    def _load(self) -> None:
        try:
            with self.path.open(encoding="utf-8") as f:
                data = json.load(f)
        except FileNotFoundError:
            self.path.parent.mkdir(parents=True, exist_ok=True)
            with self.path.open("w", encoding="utf-8") as f:
                json.dump({}, f, ensure_ascii=False, indent=2)
            data = {}
        passwords: dict[str, int] = {}
        if isinstance(data, dict):
            for password, level in data.items():
                try:
                    lvl = int(level)
                except Exception:
                    continue
                if lvl in (1, 2, 3):
                    passwords[str(password)] = lvl
        self._passwords = passwords

    def reload(self) -> None:
        self._load()

    def get_level_for_password(self, password: str) -> int | None:
        if not password:
            return None
        return self._passwords.get(password)

20. app/services/db.py  (27.8KB, 2025-11-25 19:41:52)
   –†–æ–ª—å: Service
   –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ—Ç—Å—è –º–æ–¥—É–ª—è–º–∏: app.core.bot
–ö–æ–¥:
import datetime as dt
from typing import Any

import aiosqlite


class Database:
    def __init__(self, path: str) -> None:
        self.path = path

    async def init(self) -> None:
        async with aiosqlite.connect(self.path) as db:
            await db.execute(
                """
                CREATE TABLE IF NOT EXISTS users (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    tg_id INTEGER UNIQUE NOT NULL,
                    username TEXT,
                    first_name TEXT,
                    last_name TEXT,
                    tos_accepted INTEGER NOT NULL DEFAULT 0,
                    group_code TEXT,
                    created_at TEXT NOT NULL
                )
                """
            )
            cursor = await db.execute("PRAGMA table_info(users)")
            rows = await cursor.fetchall()
            column_names = {row[1] for row in rows}
            if "is_blocked" not in column_names:
                await db.execute(
                    "ALTER TABLE users "
                    "ADD COLUMN is_blocked INTEGER NOT NULL DEFAULT 0"
                )
            if "schedule_notify_enabled" not in column_names:
                await db.execute(
                    "ALTER TABLE users "
                    "ADD COLUMN schedule_notify_enabled INTEGER NOT NULL DEFAULT 1"
                )
            await db.execute(
                """
                CREATE TABLE IF NOT EXISTS admin_sessions (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    tg_id INTEGER NOT NULL,
                    level INTEGER NOT NULL,
                    password TEXT NOT NULL,
                    active INTEGER NOT NULL DEFAULT 1,
                    created_at TEXT NOT NULL
                )
                """
            )
            await db.execute(
                """
                CREATE TABLE IF NOT EXISTS admin_login_limits (
                    tg_id INTEGER PRIMARY KEY,
                    attempts_left INTEGER NOT NULL,
                    blocked_until TEXT
                )
                """
            )
            await db.execute(
                """
                CREATE TABLE IF NOT EXISTS banned_users (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    tg_id INTEGER,
                    username TEXT,
                    reason TEXT,
                    created_at TEXT NOT NULL
                )
                """
            )
            await db.execute(
                """
                CREATE TABLE IF NOT EXISTS premium_users (
                    tg_id INTEGER PRIMARY KEY,
                    until TEXT NOT NULL
                )
                """
            )
            await db.execute(
                """
                CREATE TABLE IF NOT EXISTS stewards (
                    tg_id INTEGER PRIMARY KEY,
                    group_code TEXT NOT NULL
                )
                """
            )
            await db.execute(
                """
                CREATE TABLE IF NOT EXISTS homework_notifications (
                    tg_id INTEGER PRIMARY KEY,
                    minutes_before INTEGER NOT NULL
                )
                """
            )
            await db.commit()

    async def ensure_user(
        self,
        tg_id: int,
        username: str | None,
        first_name: str | None,
        last_name: str | None,
    ) -> None:
        async with aiosqlite.connect(self.path) as db:
            await db.execute(
                """
                INSERT OR IGNORE INTO users (
                    tg_id,
                    username,
                    first_name,
                    last_name,
                    tos_accepted,
                    group_code,
                    is_blocked,
                    created_at
                )
                VALUES (?, ?, ?, ?, 0, NULL, 0, ?)
                """,
                (
                    tg_id,
                    username,
                    first_name,
                    last_name,
                    dt.datetime.utcnow().isoformat(),
                ),
            )
            await db.execute(
                """
                UPDATE users
                SET username = ?, first_name = ?, last_name = ?
                WHERE tg_id = ?
                """,
                (
                    username,
                    first_name,
                    last_name,
                    tg_id,
                ),
            )
            await db.commit()

    async def accept_tos(
        self,
        tg_id: int,
        username: str | None,
        first_name: str | None,
        last_name: str | None,
    ) -> None:
        async with aiosqlite.connect(self.path) as db:
            await db.execute(
                """
                INSERT OR IGNORE INTO users (
                    tg_id,
                    username,
                    first_name,
                    last_name,
                    tos_accepted,
                    group_code,
                    is_blocked,
                    created_at
                )
                VALUES (?, ?, ?, ?, 1, NULL, 0, ?)
                """,
                (
                    tg_id,
                    username,
                    first_name,
                    last_name,
                    dt.datetime.utcnow().isoformat(),
                ),
            )
            await db.execute(
                """
                UPDATE users
                SET tos_accepted = 1,
                    username = ?,
                    first_name = ?,
                    last_name = ?
                WHERE tg_id = ?
                """,
                (
                    username,
                    first_name,
                    last_name,
                    tg_id,
                ),
            )
            await db.commit()

    async def get_user(self, tg_id: int) -> dict[str, Any] | None:
        async with aiosqlite.connect(self.path) as db:
            db.row_factory = aiosqlite.Row
            cursor = await db.execute(
                """
                SELECT
                    id,
                    tg_id,
                    username,
                    first_name,
                    last_name,
                    tos_accepted,
                    group_code,
                    is_blocked,
                    created_at
                FROM users
                WHERE tg_id = ?
                """,
                (tg_id,),
            )
            row = await cursor.fetchone()
            if not row:
                return None
            return dict(row)

    async def set_user_group(self, tg_id: int, group_code: str) -> None:
        async with aiosqlite.connect(self.path) as db:
            await db.execute(
                """
                INSERT OR IGNORE INTO users (
                    tg_id,
                    username,
                    first_name,
                    last_name,
                    tos_accepted,
                    group_code,
                    is_blocked,
                    created_at
                )
                VALUES (?, NULL, NULL, NULL, 0, ?, 0, ?)
                """,
                (
                    tg_id,
                    group_code,
                    dt.datetime.utcnow().isoformat(),
                ),
            )
            await db.execute(
                "UPDATE users SET group_code = ? WHERE tg_id = ?",
                (group_code, tg_id),
            )
            await db.commit()

    async def set_user_blocked(self, tg_id: int, blocked: bool) -> None:
        async with aiosqlite.connect(self.path) as db:
            await db.execute(
                "UPDATE users SET is_blocked = ? WHERE tg_id = ?",
                (1 if blocked else 0, tg_id),
            )
            await db.commit()

    async def list_users_page(
        self,
        page: int,
        per_page: int,
    ) -> tuple[list[dict[str, Any]], int, int]:
        async with aiosqlite.connect(self.path) as db:
            db.row_factory = aiosqlite.Row
            cursor = await db.execute("SELECT COUNT(*) AS c FROM users")
            row = await cursor.fetchone()
            total = row["c"] if row else 0
            if total == 0:
                return [], 0, 0
            pages = (total + per_page - 1) // per_page
            if page < 1:
                page = 1
            if page > pages:
                page = pages
            offset = (page - 1) * per_page
            cursor = await db.execute(
                """
                SELECT
                    u.id,
                    u.tg_id,
                    u.username,
                    u.first_name,
                    u.last_name,
                    u.group_code,
                    u.is_blocked,
                    EXISTS(
                        SELECT 1
                        FROM admin_sessions s
                        WHERE s.tg_id = u.tg_id
                          AND s.active = 1
                    ) AS is_admin
                FROM users u
                ORDER BY u.id
                LIMIT ? OFFSET ?
                """,
                (per_page, offset),
            )
            rows = await cursor.fetchall()
            users = [dict(r) for r in rows]
            return users, total, pages

    async def get_users_stats(self) -> dict[str, int]:
        async with aiosqlite.connect(self.path) as db:
            db.row_factory = aiosqlite.Row
            cursor = await db.execute("SELECT COUNT(*) AS c FROM users")
            row = await cursor.fetchone()
            total = row["c"] if row else 0
            cursor = await db.execute(
                "SELECT COUNT(*) AS c FROM users WHERE is_blocked = 1"
            )
            row = await cursor.fetchone()
            blocked = row["c"] if row else 0
            cursor = await db.execute(
                "SELECT COUNT(*) AS c FROM users WHERE group_code IS NOT NULL"
            )
            row = await cursor.fetchone()
            with_group = row["c"] if row else 0
            cursor = await db.execute(
                "SELECT COUNT(*) AS c FROM admin_sessions WHERE active = 1"
            )
            row = await cursor.fetchone()
            active_admins = row["c"] if row else 0
            return {
                "total": total,
                "blocked": blocked,
                "with_group": with_group,
                "active_admins": active_admins,
            }

    async def search_users(self, query: str) -> list[dict[str, Any]]:
        async with aiosqlite.connect(self.path) as db:
            db.row_factory = aiosqlite.Row
            if query.isdigit():
                cursor = await db.execute(
                    """
                    SELECT
                        u.id,
                        u.tg_id,
                        u.username,
                        u.first_name,
                        u.last_name,
                        u.group_code,
                        u.is_blocked,
                        EXISTS(
                            SELECT 1
                            FROM admin_sessions s
                            WHERE s.tg_id = u.tg_id
                              AND s.active = 1
                        ) AS is_admin
                    FROM users u
                    WHERE u.tg_id = ?
                    ORDER BY u.id
                    """,
                    (int(query),),
                )
            else:
                username = query.lstrip("@").lower()
                cursor = await db.execute(
                    """
                    SELECT
                        u.id,
                        u.tg_id,
                        u.username,
                        u.first_name,
                        u.last_name,
                        u.group_code,
                        u.is_blocked,
                        EXISTS(
                            SELECT 1
                            FROM admin_sessions s
                            WHERE s.tg_id = u.tg_id
                              AND s.active = 1
                        ) AS is_admin
                    FROM users u
                    WHERE LOWER(u.username) LIKE ?
                    ORDER BY u.id
                    """,
                    (username + "%",),
                )
            rows = await cursor.fetchall()
            return [dict(r) for r in rows]

    async def get_active_admin_session_for_user(
        self,
        tg_id: int,
    ) -> dict[str, Any] | None:
        async with aiosqlite.connect(self.path) as db:
            db.row_factory = aiosqlite.Row
            cursor = await db.execute(
                """
                SELECT id, tg_id, level, password, active, created_at
                FROM admin_sessions
                WHERE tg_id = ? AND active = 1
                ORDER BY id DESC
                LIMIT 1
                """,
                (tg_id,),
            )
            row = await cursor.fetchone()
            if not row:
                return None
            return dict(row)

    async def get_active_admin_session_by_password(
        self,
        password: str,
    ) -> dict[str, Any] | None:
        async with aiosqlite.connect(self.path) as db:
            db.row_factory = aiosqlite.Row
            cursor = await db.execute(
                """
                SELECT id, tg_id, level, password, active, created_at
                FROM admin_sessions
                WHERE password = ? AND active = 1
                ORDER BY id DESC
                LIMIT 1
                """,
                (password,),
            )
            row = await cursor.fetchone()
            if not row:
                return None
            return dict(row)

    async def create_admin_session(
        self,
        tg_id: int,
        level: int,
        password: str,
    ) -> int:
        async with aiosqlite.connect(self.path) as db:
            now = dt.datetime.utcnow().isoformat()
            cursor = await db.execute(
                """
                INSERT INTO admin_sessions (
                    tg_id,
                    level,
                    password,
                    active,
                    created_at
                )
                VALUES (?, ?, ?, 1, ?)
                """,
                (tg_id, level, password, now),
            )
            await db.commit()
            return cursor.lastrowid

    async def deactivate_admin_sessions_for_user(self, tg_id: int) -> None:
        async with aiosqlite.connect(self.path) as db:
            await db.execute(
                "UPDATE admin_sessions SET active = 0 WHERE tg_id = ? AND active = 1",
                (tg_id,),
            )
            await db.commit()

    async def get_active_admin_sessions_with_users(self) -> list[dict[str, Any]]:
        async with aiosqlite.connect(self.path) as db:
            db.row_factory = aiosqlite.Row
            cursor = await db.execute(
                """
                SELECT
                    s.id,
                    s.tg_id,
                    s.level,
                    s.password,
                    s.active,
                    s.created_at,
                    u.username,
                    u.first_name,
                    u.last_name
                FROM admin_sessions s
                LEFT JOIN users u ON u.tg_id = s.tg_id
                WHERE s.active = 1
                ORDER BY s.created_at DESC
                """
            )
            rows = await cursor.fetchall()
            return [dict(r) for r in rows]

    async def get_admin_session_by_id(
        self,
        session_id: int,
    ) -> dict[str, Any] | None:
        async with aiosqlite.connect(self.path) as db:
            db.row_factory = aiosqlite.Row
            cursor = await db.execute(
                """
                SELECT id, tg_id, level, password, active, created_at
                FROM admin_sessions
                WHERE id = ?
                """,
                (session_id,),
            )
            row = await cursor.fetchone()
            if not row:
                return None
            return dict(row)

    async def deactivate_admin_session_by_id(self, session_id: int) -> None:
        async with aiosqlite.connect(self.path) as db:
            await db.execute(
                "UPDATE admin_sessions SET active = 0 WHERE id = ?",
                (session_id,),
            )
            await db.commit()

    async def get_admin_login_limits(
        self,
        tg_id: int,
    ) -> dict[str, Any] | None:
        async with aiosqlite.connect(self.path) as db:
            db.row_factory = aiosqlite.Row
            cursor = await db.execute(
                """
                SELECT tg_id, attempts_left, blocked_until
                FROM admin_login_limits
                WHERE tg_id = ?
                """,
                (tg_id,),
            )
            row = await cursor.fetchone()
            if not row:
                return None
            return dict(row)

    async def set_admin_login_limits(
        self,
        tg_id: int,
        attempts_left: int,
        blocked_until: str | None,
    ) -> None:
        async with aiosqlite.connect(self.path) as db:
            await db.execute(
                """
                INSERT INTO admin_login_limits (tg_id, attempts_left, blocked_until)
                VALUES (?, ?, ?)
                ON CONFLICT(tg_id) DO UPDATE SET
                    attempts_left = excluded.attempts_left,
                    blocked_until = excluded.blocked_until
                """,
                (tg_id, attempts_left, blocked_until),
            )
            await db.commit()

    async def clear_admin_login_limits(self, tg_id: int) -> None:
        async with aiosqlite.connect(self.path) as db:
            await db.execute(
                "DELETE FROM admin_login_limits WHERE tg_id = ?",
                (tg_id,),
            )
            await db.commit()

    async def get_all_users_for_broadcast(self) -> list[dict[str, Any]]:
        async with aiosqlite.connect(self.path) as db:
            db.row_factory = aiosqlite.Row
            cursor = await db.execute(
                """
                SELECT tg_id, username, is_blocked
                FROM users
                ORDER BY id
                """
            )
            rows = await cursor.fetchall()
            return [dict(r) for r in rows]

    async def ban_user(
        self,
        tg_id: int | None,
        username: str | None,
        reason: str,
    ) -> None:
        async with aiosqlite.connect(self.path) as db:
            username_norm = username.lower() if username else None
            if tg_id is not None:
                await db.execute(
                    "DELETE FROM banned_users WHERE tg_id = ?",
                    (tg_id,),
                )
            if username_norm:
                await db.execute(
                    "DELETE FROM banned_users WHERE LOWER(username) = ?",
                    (username_norm,),
                )
            now = dt.datetime.utcnow().isoformat()
            await db.execute(
                """
                INSERT INTO banned_users (tg_id, username, reason, created_at)
                VALUES (?, ?, ?, ?)
                """,
                (tg_id, username, reason, now),
            )
            await db.commit()

    async def unban_by_tg_id(self, tg_id: int) -> int:
        async with aiosqlite.connect(self.path) as db:
            cursor = await db.execute(
                "DELETE FROM banned_users WHERE tg_id = ?",
                (tg_id,),
            )
            await db.commit()
            return cursor.rowcount

    async def unban_by_username(self, username: str) -> int:
        async with aiosqlite.connect(self.path) as db:
            username_norm = username.lower()
            cursor = await db.execute(
                "DELETE FROM banned_users WHERE LOWER(username) = ?",
                (username_norm,),
            )
            await db.commit()
            return cursor.rowcount

    async def get_banned_users(self) -> list[dict[str, Any]]:
        async with aiosqlite.connect(self.path) as db:
            db.row_factory = aiosqlite.Row
            cursor = await db.execute(
                """
                SELECT id, tg_id, username, reason, created_at
                FROM banned_users
                ORDER BY created_at DESC, id DESC
                """
            )
            rows = await cursor.fetchall()
            return [dict(r) for r in rows]

    async def get_ban_for_user(
        self,
        tg_id: int,
        username: str | None,
    ) -> dict[str, Any] | None:
        async with aiosqlite.connect(self.path) as db:
            db.row_factory = aiosqlite.Row
            username_norm = username.lower() if username else None
            if username_norm:
                cursor = await db.execute(
                    """
                    SELECT id, tg_id, username, reason, created_at
                    FROM banned_users
                    WHERE tg_id = ? OR LOWER(username) = ?
                    ORDER BY created_at DESC, id DESC
                    LIMIT 1
                    """,
                    (tg_id, username_norm),
                )
            else:
                cursor = await db.execute(
                    """
                    SELECT id, tg_id, username, reason, created_at
                    FROM banned_users
                    WHERE tg_id = ?
                    ORDER BY created_at DESC, id DESC
                    LIMIT 1
                    """,
                    (tg_id,),
                )
            row = await cursor.fetchone()
            if not row:
                return None
            return dict(row)

    async def is_user_banned(self, tg_id: int, username: str | None) -> bool:
        entry = await self.get_ban_for_user(tg_id, username)
        return entry is not None

    async def is_user_premium(self, tg_id: int) -> bool:
        async with aiosqlite.connect(self.path) as db:
            db.row_factory = aiosqlite.Row
            cursor = await db.execute(
                "SELECT until FROM premium_users WHERE tg_id = ?",
                (tg_id,),
            )
            row = await cursor.fetchone()
            if not row:
                return False
            try:
                until = dt.datetime.fromisoformat(row["until"])
            except Exception:
                return False
            return until > dt.datetime.utcnow()

    async def set_user_premium(self, tg_id: int, until: dt.datetime) -> None:
        async with aiosqlite.connect(self.path) as db:
            await db.execute(
                """
                INSERT INTO premium_users (tg_id, until)
                VALUES (?, ?)
                ON CONFLICT(tg_id) DO UPDATE SET until = excluded.until
                """,
                (tg_id, until.isoformat()),
            )
            await db.commit()

    async def get_user_premium_until(self, tg_id: int) -> dt.datetime | None:
        async with aiosqlite.connect(self.path) as db:
            db.row_factory = aiosqlite.Row
            cursor = await db.execute(
                "SELECT until FROM premium_users WHERE tg_id = ?",
                (tg_id,),
            )
            row = await cursor.fetchone()
            if not row:
                return None
            try:
                until = dt.datetime.fromisoformat(row["until"])
            except Exception:
                return None
            if until <= dt.datetime.utcnow():
                return None
            return until

    async def get_schedule_notify_enabled(self, tg_id: int) -> bool:
        async with aiosqlite.connect(self.path) as db:
            db.row_factory = aiosqlite.Row
            cursor = await db.execute(
                "SELECT schedule_notify_enabled FROM users WHERE tg_id = ?",
                (tg_id,),
            )
            row = await cursor.fetchone()
            if not row:
                return True
            value = row["schedule_notify_enabled"]
            if value is None:
                return True
            return bool(value)

    async def set_schedule_notify_enabled(self, tg_id: int, enabled: bool) -> None:
        async with aiosqlite.connect(self.path) as db:
            await db.execute(
                "UPDATE users SET schedule_notify_enabled = ? WHERE tg_id = ?",
                (1 if enabled else 0, tg_id),
            )
            await db.commit()

    async def get_users_for_schedule_notifications(self, group_code: str) -> list[dict[str, Any]]:
        async with aiosqlite.connect(self.path) as db:
            db.row_factory = aiosqlite.Row
            cursor = await db.execute(
                """
                SELECT tg_id, username, is_blocked, schedule_notify_enabled
                FROM users
                WHERE group_code = ?
                """,
                (group_code,),
            )
            rows = await cursor.fetchall()
            result: list[dict[str, Any]] = []
            for r in rows:
                item = dict(r)
                tg_id = item.get("tg_id")
                if not tg_id:
                    continue
                if item.get("is_blocked"):
                    continue
                value = item.get("schedule_notify_enabled")
                enabled = True if value is None else bool(value)
                if not enabled:
                    continue
                result.append(item)
            return result

    async def set_steward(self, tg_id: int, group_code: str) -> None:
        async with aiosqlite.connect(self.path) as db:
            await db.execute(
                """
                INSERT INTO stewards (tg_id, group_code)
                VALUES (?, ?)
                ON CONFLICT(tg_id) DO UPDATE SET group_code = excluded.group_code
                """,
                (tg_id, group_code),
            )
            await db.commit()

    async def remove_steward(self, tg_id: int) -> None:
        async with aiosqlite.connect(self.path) as db:
            await db.execute(
                "DELETE FROM stewards WHERE tg_id = ?",
                (tg_id,),
            )
            await db.commit()

    async def get_steward_group(self, tg_id: int) -> str | None:
        async with aiosqlite.connect(self.path) as db:
            db.row_factory = aiosqlite.Row
            cursor = await db.execute(
                "SELECT group_code FROM stewards WHERE tg_id = ?",
                (tg_id,),
            )
            row = await cursor.fetchone()
            if not row:
                return None
            return row["group_code"]

    async def list_stewards(self) -> list[dict[str, Any]]:
        async with aiosqlite.connect(self.path) as db:
            db.row_factory = aiosqlite.Row
            cursor = await db.execute(
                """
                SELECT
                    s.tg_id,
                    s.group_code,
                    u.username,
                    u.first_name,
                    u.last_name
                FROM stewards s
                LEFT JOIN users u ON u.tg_id = s.tg_id
                ORDER BY s.group_code, s.tg_id
                """
            )
            rows = await cursor.fetchall()
            return [dict(r) for r in rows]

    async def get_homework_notify_minutes(self, tg_id: int) -> int | None:
        async with aiosqlite.connect(self.path) as db:
            db.row_factory = aiosqlite.Row
            cursor = await db.execute(
                "SELECT minutes_before FROM homework_notifications WHERE tg_id = ?",
                (tg_id,),
            )
            row = await cursor.fetchone()
            if not row:
                return None
            return int(row["minutes_before"])

    async def set_homework_notify_minutes(self, tg_id: int, minutes_before: int) -> None:
        async with aiosqlite.connect(self.path) as db:
            await db.execute(
                """
                INSERT INTO homework_notifications (tg_id, minutes_before)
                VALUES (?, ?)
                ON CONFLICT(tg_id) DO UPDATE SET minutes_before = excluded.minutes_before
                """,
                (tg_id, minutes_before),
            )
            await db.commit()

21. app/services/group_service.py  (1.7KB, 2025-11-22 00:03:15)
   –†–æ–ª—å: Service
   –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ—Ç—Å—è –º–æ–¥—É–ª—è–º–∏: app.core.bot
–ö–æ–¥:
import json
from pathlib import Path


class GroupResolver:
    def __init__(self, groups_path: Path, aliases_path: Path):
        self._map = {}
        self._load_groups(groups_path)
        self._load_aliases(aliases_path)

    def _normalize(self, value: str) -> str:
        if value is None:
            return ""
        s = value.strip().upper()
        s = s.replace(" ", "")
        s = s.replace("‚Äì", "-")
        s = s.replace("‚Äî", "-")
        return s

    def _load_groups(self, path: Path) -> None:
        try:
            with path.open(encoding="utf-8") as f:
                data = json.load(f)
        except FileNotFoundError:
            data = {}
        if isinstance(data, dict):
            for canonical in data.keys():
                norm = self._normalize(canonical)
                if norm:
                    self._map[norm] = canonical

    def _load_aliases(self, path: Path) -> None:
        try:
            with path.open(encoding="utf-8") as f:
                data = json.load(f)
        except FileNotFoundError:
            data = {}
        if not isinstance(data, dict):
            return
        for canonical, aliases in data.items():
            canonical_norm = self._normalize(canonical)
            if canonical_norm:
                self._map[canonical_norm] = canonical
            if isinstance(aliases, list):
                for alias in aliases:
                    alias_norm = self._normalize(alias)
                    if alias_norm:
                        self._map[alias_norm] = canonical

    def resolve(self, raw_value: str | None) -> str | None:
        norm = self._normalize(raw_value or "")
        if not norm:
            return None
        return self._map.get(norm)

22. app/services/homework_service.py  (17.9KB, 2025-11-26 22:58:38)
   –†–æ–ª—å: Service
   –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ—Ç—Å—è –º–æ–¥—É–ª—è–º–∏: app.core.bot
–ö–æ–¥:
import datetime as dt
import json
import uuid
from html import escape
from io import BytesIO
from pathlib import Path
from typing import Any

import aiohttp


class HomeworkService:
    def __init__(
        self,
        db,
        times_path: Path,
        models_path: Path,
        homeworks_dir: Path,
        freeimage_api_key: str | None,
        telegraph_token: str | None,
    ):
        self.db = db
        self.times_path = times_path
        self.models_path = models_path
        self.homeworks_dir = homeworks_dir
        self.freeimage_api_key = freeimage_api_key
        self.telegraph_token = telegraph_token
        self.homeworks_dir.mkdir(parents=True, exist_ok=True)
        self.personal_path = self.homeworks_dir / "personal.json"
        self.public_path = self.homeworks_dir / "public.json"
        self.pending_path = self.homeworks_dir / "pending.json"
        self.ai_logs_path = self.homeworks_dir / "ai_logs.jsonl"
        self.ai_config_path = self.homeworks_dir / "ai_config.json"
        self._ensure_files()

    def _ensure_files(self) -> None:
        if not self.personal_path.exists():
            self.personal_path.write_text("[]", encoding="utf-8")
        if not self.public_path.exists():
            self.public_path.write_text("[]", encoding="utf-8")
        if not self.pending_path.exists():
            self.pending_path.write_text("[]", encoding="utf-8")
        if not self.ai_logs_path.exists():
            self.ai_logs_path.write_text("", encoding="utf-8")
        if not self.ai_config_path.exists():
            data = {
                "model": "pollinations/llama-3.1-70b-instruct",
                "temperature": 0.2,
                "system_prompt": "–¢—ã –ø—Ä–æ–≤–µ—Ä—è–µ—à—å –¥–æ–º–∞—à–Ω–µ–µ –∑–∞–¥–∞–Ω–∏–µ —Å—Ç—É–¥–µ–Ω—Ç–æ–≤. –û—Ç–≤–µ—á–∞–π —Ç–æ–ª—å–∫–æ –≤ JSON —Å –ø–æ–ª–µ–º decision: '–¥–∞' –∏–ª–∏ '–Ω–µ—Ç', –∏ –ø–æ–ª–µ–º reason —Å –∫–æ—Ä–æ—Ç–∫–∏–º –æ–±—ä—è—Å–Ω–µ–Ω–∏–µ–º.",
                "auto_accept": False,
            }
            self.ai_config_path.write_text(json.dumps(data, ensure_ascii=False, indent=2), encoding="utf-8")
        if not self.models_path.exists():
            self.models_path.write_text(json.dumps({"models": [], "updated_at": None}, ensure_ascii=False, indent=2), encoding="utf-8")

    def _load_json_list(self, path: Path) -> list[dict]:
        try:
            raw = path.read_text(encoding="utf-8")
            data = json.loads(raw or "[]")
            if isinstance(data, list):
                return data
            return []
        except Exception:
            return []

    def _save_json_list(self, path: Path, items: list[dict]) -> None:
        path.write_text(json.dumps(items, ensure_ascii=False, indent=2), encoding="utf-8")

    def _now_iso(self) -> str:
        return dt.datetime.utcnow().isoformat()

    async def is_premium(self, user_id: int) -> bool:
        return await self.db.is_user_premium(user_id)

    def _load_personal_hw(self, user_id: int) -> list[dict]:
        items = self._load_json_list(self.personal_path)
        return [i for i in items if i.get("user_id") == user_id]

    def add_personal_homework(
        self,
        user_id: int,
        subject: str,
        text: str,
        telegraph_url: str | None,
        delete_at: dt.datetime | None,
    ) -> None:
        items = self._load_json_list(self.personal_path)
        new_item = {
            "id": str(uuid.uuid4()),
            "user_id": user_id,
            "subject": subject,
            "text": text,
            "telegraph_url": telegraph_url,
            "created_at": self._now_iso(),
            "delete_at": delete_at.isoformat() if delete_at else None,
        }
        items.append(new_item)
        self._save_json_list(self.personal_path, items)

    async def delete_personal_homework(self, user_id: int, subject: str) -> bool:
        items = self._load_json_list(self.personal_path)
        before = len(items)
        items = [i for i in items if not (i.get("user_id") == user_id and i.get("subject") == subject)]
        self._save_json_list(self.personal_path, items)
        return len(items) < before

    async def edit_personal_homework_text(self, user_id: int, hw_id: str, new_text: str) -> bool:
        items = self._load_json_list(self.personal_path)
        changed = False
        for i in items:
            if i.get("user_id") == user_id and i.get("id") == hw_id:
                i["text"] = new_text
                changed = True
                break
        if changed:
            self._save_json_list(self.personal_path, items)
        return changed

    async def format_personal_view(self, user_id: int) -> str:
        items = self._load_personal_hw(user_id)
        if not items:
            return "–£ –≤–∞—Å –ø–æ–∫–∞ –Ω–µ—Ç –ª–∏—á–Ω—ã—Ö –¥–æ–º–∞—à–Ω–∏—Ö –∑–∞–¥–∞–Ω–∏–π."
        lines: list[str] = ["<b>–í–∞—à–∏ –ª–∏—á–Ω—ã–µ –¥–æ–º–∞—à–Ω–∏–µ –∑–∞–¥–∞–Ω–∏—è</b>", ""]
        items_sorted = sorted(items, key=lambda x: x.get("created_at") or "")
        for item in items_sorted:
            subject = escape(item.get("subject") or "–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è")
            text = escape(item.get("text") or "")
            telegraph_url = item.get("telegraph_url")
            lines.append(f"üìå <b>{subject}</b>")
            if text:
                lines.append(text)
            if telegraph_url:
                lines.append(f"–§–æ—Ç–æ: <a href=\"{escape(telegraph_url)}\">–æ—Ç–∫—Ä—ã—Ç—å</a>")
            lines.append("")
        return "\n".join(lines)

    def _load_public_hw_all(self) -> list[dict]:
        return self._load_json_list(self.public_path)

    def add_public_homework(
        self,
        group_code: str,
        subject: str,
        text: str,
        telegraph_url: str | None,
    ) -> None:
        items = self._load_json_list(self.public_path)
        new_item = {
            "id": str(uuid.uuid4()),
            "group_code": group_code,
            "subject": subject,
            "text": text,
            "telegraph_url": telegraph_url,
            "created_at": self._now_iso(),
        }
        items.append(new_item)
        self._save_json_list(self.public_path, items)

    async def format_public_view(self, group_code: str) -> str:
        all_items = self._load_public_hw_all()
        items = [i for i in all_items if (i.get("group_code") or "").upper() == group_code.upper()]
        if not items:
            return (
                f"–î–ª—è –≥—Ä—É–ø–ø—ã <b>{escape(group_code)}</b> –µ—â—ë –Ω–µ—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã—Ö –æ–±—â–∏—Ö –¥–æ–º–∞—à–Ω–∏—Ö –∑–∞–¥–∞–Ω–∏–π.\n"
                "–í—ã –º–æ–∂–µ—Ç–µ –ø—Ä–µ–¥–ª–æ–∂–∏—Ç—å –∑–∞–¥–∞–Ω–∏–µ —á–µ—Ä–µ–∑ –∫–Ω–æ–ø–∫—É ¬´üìù –ü—Ä–µ–¥–ª–æ–∂–∏—Ç—å –æ–±—â–µ–µ –¥–∑¬ª."
            )
        lines: list[str] = [f"<b>–û–±—â–∞—è –¥–æ–º–∞—à–∫–∞ –¥–ª—è –≥—Ä—É–ø–ø—ã {escape(group_code)}</b>", ""]
        items_sorted = sorted(items, key=lambda x: x.get("created_at") or "")
        for item in items_sorted:
            subject = escape(item.get("subject") or "–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è")
            text = escape(item.get("text") or "")
            telegraph_url = item.get("telegraph_url")
            created_at = item.get("created_at")
            dt_text = ""
            if created_at:
                try:
                    dt_obj = dt.datetime.fromisoformat(created_at)
                    dt_text = dt_obj.strftime("%d.%m.%Y %H:%M")
                except Exception:
                    dt_text = created_at
            lines.append(f"üìå <b>{subject}</b>")
            if dt_text:
                lines.append(f"–î–æ–±–∞–≤–ª–µ–Ω–æ: <code>{escape(dt_text)}</code>")
            if text:
                lines.append(text)
            if telegraph_url:
                lines.append(f"–§–æ—Ç–æ: <a href=\"{escape(telegraph_url)}\">–æ—Ç–∫—Ä—ã—Ç—å</a>")
            lines.append("")
        return "\n".join(lines)

    def add_public_pending(
        self,
        user_id: int,
        username: str | None,
        full_name: str | None,
        group_code: str,
        subject: str,
        text: str,
        telegraph_url: str | None,
        ai_result: dict | None,
    ) -> None:
        items = self._load_json_list(self.pending_path)
        new_item = {
            "id": str(uuid.uuid4()),
            "user_id": user_id,
            "username": username,
            "full_name": full_name,
            "group_code": group_code,
            "subject": subject,
            "text": text,
            "telegraph_url": telegraph_url,
            "ai_result": ai_result or {},
            "created_at": self._now_iso(),
        }
        items.append(new_item)
        self._save_json_list(self.pending_path, items)

    def load_public_pending_page(self, page: int, per_page: int = 10) -> tuple[list[dict], int, int]:
        items = self._load_json_list(self.pending_path)
        total = len(items)
        if total == 0:
            return [], 0, 0
        items_sorted = sorted(items, key=lambda x: x.get("created_at") or "", reverse=True)
        pages = (total + per_page - 1) // per_page
        if page < 1:
            page = 1
        if page > pages:
            page = pages
        start = (page - 1) * per_page
        end = start + per_page
        return items_sorted[start:end], total, pages

    def get_pending_request(self, req_id: str) -> dict | None:
        items = self._load_json_list(self.pending_path)
        for it in items:
            if it.get("id") == req_id:
                return it
        return None

    def remove_pending_request(self, req_id: str) -> None:
        items = self._load_json_list(self.pending_path)
        items = [i for i in items if i.get("id") != req_id]
        self._save_json_list(self.pending_path, items)

    def append_ai_log(
        self,
        user_id: int,
        username: str | None,
        full_name: str | None,
        subject: str,
        text: str,
        telegraph_url: str | None,
        result: dict | None,
    ) -> None:
        entry = {
            "timestamp": self._now_iso(),
            "user_id": user_id,
            "username": username,
            "full_name": full_name,
            "subject": subject,
            "text": text,
            "telegraph_url": telegraph_url,
            "ai_result": result or {},
        }
        with self.ai_logs_path.open("a", encoding="utf-8") as f:
            f.write(json.dumps(entry, ensure_ascii=False) + "\n")

    def load_ai_logs_page(self, page: int, per_page: int = 10) -> tuple[list[dict], int, int]:
        entries: list[dict] = []
        if self.ai_logs_path.exists():
            with self.ai_logs_path.open(encoding="utf-8") as f:
                for line in f:
                    line = line.strip()
                    if not line:
                        continue
                    try:
                        data = json.loads(line)
                    except Exception:
                        continue
                    if isinstance(data, dict):
                        entries.append(data)
        entries_sorted = sorted(entries, key=lambda x: x.get("timestamp") or "", reverse=True)
        total = len(entries_sorted)
        if total == 0:
            return [], 0, 0
        pages = (total + per_page - 1) // per_page
        if page < 1:
            page = 1
        if page > pages:
            page = pages
        start = (page - 1) * per_page
        end = start + per_page
        return entries_sorted[start:end], total, pages

    def load_ai_config(self) -> dict:
        try:
            raw = self.ai_config_path.read_text(encoding="utf-8")
            data = json.loads(raw or "{}")
            if isinstance(data, dict):
                return data
            return {}
        except Exception:
            return {}

    def save_ai_config(self, data: dict) -> None:
        self.ai_config_path.write_text(json.dumps(data, ensure_ascii=False, indent=2), encoding="utf-8")

    def load_models(self) -> list[str]:
        try:
            raw = self.models_path.read_text(encoding="utf-8")
            data = json.loads(raw or "{}")
            if not isinstance(data, dict):
                return []
            models = data.get("models")
            if isinstance(models, list):
                return [str(m) for m in models]
            return []
        except Exception:
            return []

    async def pollinations_refresh_models(self) -> list[str]:
        url = "https://text.pollinations.ai/openai/models"
        async with aiohttp.ClientSession() as session:
            async with session.get(url) as resp:
                try:
                    payload = await resp.json()
                except Exception:
                    payload = []
        models: list[str] = []
        if isinstance(payload, list):
            for m in payload:
                if isinstance(m, dict):
                    name = m.get("id") or m.get("name")
                    if name:
                        models.append(str(name))
        data = {
            "models": models,
            "updated_at": self._now_iso(),
        }
        self.models_path.write_text(json.dumps(data, ensure_ascii=False, indent=2), encoding="utf-8")
        return models

    async def pollinations_check_homework(self, text: str) -> dict:
        config = self.load_ai_config()
        model = config.get("model") or "pollinations/llama-3.1-70b-instruct"
        temperature = float(config.get("temperature", 0.2))
        system_prompt = config.get("system_prompt") or "–û—Ç–≤–µ—á–∞–π —Ç–æ–ª—å–∫–æ JSON —Å decision –∏ reason."
        url = "https://text.pollinations.ai/openai/v1/chat/completions"
        headers = {"Content-Type": "application/json"}
        payload = {
            "model": model,
            "temperature": temperature,
            "messages": [
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": text},
            ],
        }
        async with aiohttp.ClientSession() as session:
            try:
                async with session.post(url, headers=headers, json=payload, timeout=60) as resp:
                    raw = await resp.text()
            except Exception as e:
                return {"decision": "–Ω–µ—Ç", "reason": f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞—â–µ–Ω–∏–∏ –∫ API: {e}", "raw": None}
        parsed: dict[str, Any] | None = None
        try:
            data = json.loads(raw)
            if isinstance(data, dict):
                choices = data.get("choices")
                if isinstance(choices, list) and choices:
                    msg = choices[0].get("message") or {}
                    content = msg.get("content") or ""
                    parsed = json.loads(content)
        except Exception:
            parsed = None
        if not isinstance(parsed, dict):
            return {"decision": "–Ω–µ—Ç", "reason": "–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞–∑–æ–±—Ä–∞—Ç—å –æ—Ç–≤–µ—Ç –º–æ–¥–µ–ª–∏", "raw": raw}
        decision = str(parsed.get("decision") or "").strip().lower()
        if decision not in {"–¥–∞", "–Ω–µ—Ç"}:
            decision = "–Ω–µ—Ç"
        return {"decision": decision, "reason": parsed.get("reason"), "raw": parsed}

    async def upload_images_and_make_telegraph(self, message) -> str | None:
        if not self.telegraph_token:
            return None
        if not message.photo:
            return None
        photos = message.photo
        file_ids = [p.file_id for p in photos]
        bot = message.bot
        file_bytes_list: list[bytes] = []
        for fid in file_ids:
            f = await bot.get_file(fid)
            buf = BytesIO()
            await bot.download_file(f.file_path, buf)
            file_bytes_list.append(buf.getvalue())
        telegraph_files: list[dict] = []
        async with aiohttp.ClientSession() as session:
            for idx, data in enumerate(file_bytes_list):
                form = aiohttp.FormData()
                form.add_field(
                    "file",
                    data,
                    filename=f"image_{idx}.jpg",
                    content_type="image/jpeg",
                )
                async with session.post("https://telegra.ph/upload", data=form) as resp:
                    uploaded = await resp.json()
                    if isinstance(uploaded, list) and uploaded and isinstance(uploaded[0], dict):
                        src = uploaded[0].get("src")
                        if src:
                            telegraph_files.append({"src": src})
        if not telegraph_files:
            return None
        content_nodes = []
        for f in telegraph_files:
            src = f["src"]
            if src.startswith("/"):
                url = "https://telegra.ph" + src
            else:
                url = src
            content_nodes.append({"tag": "img", "attrs": {"src": url}})
        page_url = await self._create_telegraph_page_with_images(message, content_nodes)
        return page_url

    async def _create_telegraph_page_with_images(self, message, nodes: list[dict]) -> str | None:
        if not self.telegraph_token:
            return None
        author_name = message.from_user.full_name or message.from_user.username or "–°—Ç—É–¥–µ–Ω—Ç"
        title = "–î–æ–º–∞—à–∫–∞"
        url = "https://api.telegra.ph/createPage"
        payload = {
            "access_token": self.telegraph_token,
            "title": title,
            "author_name": author_name,
            "content": json.dumps(nodes, ensure_ascii=False),
            "return_content": False,
        }
        async with aiohttp.ClientSession() as session:
            async with session.post(url, data=payload) as resp:
                data = await resp.json()
        if not isinstance(data, dict):
            return None
        if not data.get("ok"):
            return None
        result = data.get("result") or {}
        return result.get("url")

23. app/services/schedule_service.py  (14.1KB, 2025-11-23 23:48:55)
   –†–æ–ª—å: Schedule/Calendar
   –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ—Ç—Å—è –º–æ–¥—É–ª—è–º–∏: app.core.bot, app.handlers.admin, app.services.schedule_watchdog
–ö–æ–¥:
import asyncio
import datetime as dt
import json
import logging
import re
from pathlib import Path

import requests
from bs4 import BeautifulSoup


def week_bounds_mon_sun(d):
    monday = d - dt.timedelta(days=d.weekday())
    sunday = monday + dt.timedelta(days=6)
    return monday, sunday


def week_mon_sat_for_display(now_date):
    wd = now_date.weekday()
    if wd in (5, 6):
        shift = 7 - wd
        base = now_date + dt.timedelta(days=shift)
    else:
        base = now_date
    monday = base - dt.timedelta(days=base.weekday())
    saturday = monday + dt.timedelta(days=5)
    return monday, saturday


_DATE_RE = re.compile(r"(\d{2}\.\d{2}\.\d{4})(?:\s+(.+))?")


def _clean_text(s):
    s = (s or "").replace("\xa0", " ")
    return re.sub(r"\s+", " ", s).strip()


def _mk_full_title(cell):
    subj_tag = cell.find("a", class_="z1")
    room_tag = cell.find("a", class_="z2")
    teacher_tag = cell.find(attrs={"class": lambda x: x and ("z3" in x)})
    subj_raw = subj_tag.get_text(strip=True) if subj_tag else cell.get_text(strip=True)
    subj = re.sub(r"\(\s*\)", "", subj_raw).strip()
    parts = [
        p
        for p in [
            subj,
            room_tag.get_text(strip=True) if room_tag else "",
            teacher_tag.get_text(strip=True) if teacher_tag else "",
        ]
        if p
    ]
    return " | ".join(parts)


def fetch_page(url):
    headers = {
        "User-Agent": "Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/117.0",
        "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
    }
    r = requests.get(url, headers=headers, timeout=15)
    if r.status_code != 200:
        raise RuntimeError(f"HTTP {r.status_code}")
    return r.content


def parse_schedule(url):
    try:
        html = fetch_page(url)
        soup = BeautifulSoup(html, "html.parser")
        table = soup.find("table", class_="output-table") or soup.find("table")
        if not table:
            return {}
        rows = table.find_all("tr")
        schedule = {}
        i = 0
        n = len(rows)
        while i < n:
            row = rows[i]
            date_cell = row.find("td", attrs={"rowspan": True})
            if not date_cell:
                i += 1
                continue
            date_text = date_cell.get_text(separator="\n").strip()
            m = _DATE_RE.search(date_text)
            if not m:
                i += 1
                continue
            date = m.group(1)
            dayname = (m.group(2) or "").strip()
            schedule.setdefault(date, {"day": dayname, "pairs": {}, "pairs_cols": {}, "merge": {}})
            day_rows = rows[i : i + 8]
            i += 8
            for dr in day_rows:
                tds = dr.find_all("td")
                pair_num = None
                pair_idx = -1
                for idx, td in enumerate(tds):
                    if "hd" in (td.get("class") or []):
                        text = _clean_text(td.get_text())
                        if text.isdigit():
                            pair_num = int(text)
                            pair_idx = idx
                            break
                if pair_num is None:
                    continue
                cells = tds[pair_idx + 1 :]
                groups = [None] * 5
                col = 0
                for cell in cells:
                    span = 1
                    if cell.has_attr("colspan"):
                        try:
                            span = int(cell["colspan"])
                        except Exception:
                            span = 1
                    content = None
                    if "ur" in (cell.get("class") or []):
                        content = _mk_full_title(cell)
                    for k in range(span):
                        if col + k < 5:
                            groups[col + k] = content
                    col += span
                first = groups[0]
                second = groups[1]
                common = None
                for j in range(2, 5):
                    if groups[j] is not None:
                        common = groups[j]
                        break
                if all(g is None for g in groups):
                    continue
                if common:
                    schedule[date]["merge"][pair_num] = common
                    schedule[date]["pairs"][pair_num] = [common]
                else:
                    if first and second:
                        if first == second:
                            schedule[date]["merge"][pair_num] = first
                            schedule[date]["pairs"][pair_num] = [first]
                        else:
                            schedule[date]["pairs_cols"][pair_num] = [first, second]
                            schedule[date]["pairs"][pair_num] = [first, second]
                    elif first:
                        schedule[date]["pairs_cols"][pair_num] = [first, ""]
                        schedule[date]["pairs"][pair_num] = [first]
                    elif second:
                        schedule[date]["pairs_cols"][pair_num] = ["", second]
                        schedule[date]["pairs"][pair_num] = [second]
        for d, info in schedule.items():
            lines = []
            for i_pair in range(1, 9):
                if i_pair in info.get("merge", {}):
                    lines.append(f"{i_pair} –ø–∞—Ä–∞: {info['merge'][i_pair]}")
                    continue
                cols = info.get("pairs_cols", {}).get(i_pair, None)
                if not cols:
                    items = info.get("pairs", {}).get(i_pair, [])
                    if not items:
                        lines.append(f"{i_pair} –ø–∞—Ä–∞: –ù–ï–¢")
                    elif len(items) == 1:
                        lines.append(f"{i_pair} –ø–∞—Ä–∞: {items[0]}")
                    else:
                        lines.append(f"{i_pair} –ø–∞—Ä–∞:")
                        lines.append(f"‚ë† {items[0]}")
                        lines.append(f"‚ë° {items[1]}")
                    continue
                c1 = cols[0] if len(cols) > 0 else ""
                c2 = cols[1] if len(cols) > 1 else ""
                if not c1 and not c2:
                    lines.append(f"{i_pair} –ø–∞—Ä–∞: –ù–ï–¢")
                elif c1 and c2:
                    lines.append(f"{i_pair} –ø–∞—Ä–∞:")
                    lines.append(f"‚ë† {c1}")
                    lines.append(f"‚ë° {c2}")
                elif c1:
                    lines.append(f"{i_pair} –ø–∞—Ä–∞: ‚ë† {c1}")
                else:
                    lines.append(f"{i_pair} –ø–∞—Ä–∞: ‚ë° {c2}")
            info["lessons"] = lines
        return schedule
    except Exception as e:
        logging.error("parse error: %s", e)
        return {}


def sort_dates_all(schedule):
    def _parse(s):
        try:
            return dt.datetime.strptime(s, "%d.%m.%Y")
        except Exception:
            return dt.datetime.max

    return sorted(schedule.keys(), key=lambda k: _parse(k))


def day_name_ru(weekday):
    return [
        "–ü–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫",
        "–í—Ç–æ—Ä–Ω–∏–∫",
        "–°—Ä–µ–¥–∞",
        "–ß–µ—Ç–≤–µ—Ä–≥",
        "–ü—è—Ç–Ω–∏—Ü–∞",
        "–°—É–±–±–æ—Ç–∞",
        "–í–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ",
    ][weekday]


def normalize_day(dstr, info, max_pairs=8, subgroup=None, multiline=False):
    d = dt.datetime.strptime(dstr, "%d.%m.%Y").date()
    name = day_name_ru(d.weekday())
    return f"{name} ‚Ä¢ {dstr}", info.get("lessons", ["–ü–∞—Ä –Ω–µ—Ç—Éü§ó"])


def make_blocks(schedule, max_pairs=8, subgroup=None, multiline=False):
    blocks = []
    for d in sort_dates_all(schedule):
        header, lst = normalize_day(
            d, schedule.get(d, {}), max_pairs=max_pairs, subgroup=subgroup, multiline=multiline
        )
        blocks.append((header, lst))
    return blocks

class ScheduleService:
    def __init__(self, url_path: Path):
        url_path.parent.mkdir(parents=True, exist_ok=True)
        try:
            with url_path.open(encoding="utf-8") as f:
                data = json.load(f)
        except FileNotFoundError:
            with url_path.open("w", encoding="utf-8") as f:
                json.dump({}, f, ensure_ascii=False, indent=2)
            data = {}
        self.url_map: dict[str, str] = data if isinstance(data, dict) else {}
        self.schedule_dir = url_path.parent / "schedule"
        self.schedule_dir.mkdir(parents=True, exist_ok=True)

    def get_url_for_group(self, group_code: str) -> str | None:
        return self.url_map.get(group_code)

    def _schedule_filename(self, group_code: str, monday: dt.date, saturday: dt.date) -> Path:
        name = f"{group_code}_{monday.strftime('%d.%m.%y')}-{saturday.strftime('%d.%m.%y')}.json"
        return self.schedule_dir / name

    def _cleanup_old_files(self, current_date: dt.date) -> None:
        monday_current, saturday_current = week_mon_sat_for_display(current_date)
        for path in self.schedule_dir.glob("*.json"):
            stem = path.stem
            if "_" not in stem:
                continue
            try:
                _, range_part = stem.rsplit("_", 1)
                start_str, end_str = range_part.split("-", 1)
                start_date = dt.datetime.strptime(start_str, "%d.%m.%y").date()
                end_date = dt.datetime.strptime(end_str, "%d.%m.%y").date()
            except Exception:
                continue
            if end_date < monday_current:
                try:
                    path.unlink()
                except OSError as e:
                    logging.error("failed to delete old schedule file %s: %s", path, e)

    def _load_cached_schedule(self, group_code: str, target_date: dt.date) -> dict | None:
        for path in self.schedule_dir.glob(f"{group_code}_*.json"):
            stem = path.stem
            try:
                _, range_part = stem.rsplit("_", 1)
                start_str, end_str = range_part.split("-", 1)
                start_date = dt.datetime.strptime(start_str, "%d.%m.%y").date()
                end_date = dt.datetime.strptime(end_str, "%d.%m.%y").date()
            except Exception:
                continue
            if start_date <= target_date <= end_date:
                try:
                    with path.open(encoding="utf-8") as f:
                        data = json.load(f)
                    schedule = data.get("schedule")
                    if isinstance(schedule, dict):
                        return schedule
                except Exception as e:
                    logging.error("failed to load cached schedule %s: %s", path, e)
        return None

    def _save_schedule(self, group_code: str, base_date: dt.date, schedule: dict) -> None:
        monday, saturday = week_mon_sat_for_display(base_date)
        path = self._schedule_filename(group_code, monday, saturday)
        data = {
            "group": group_code,
            "monday": monday.strftime("%d.%m.%Y"),
            "saturday": saturday.strftime("%d.%m.%Y"),
            "schedule": schedule,
        }
        try:
            with path.open("w", encoding="utf-8") as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logging.error("failed to save schedule %s: %s", path, e)

    async def _fetch_schedule_for_group(self, group_code: str, base_date: dt.date) -> dict:
        self._cleanup_old_files(base_date)
        cached = self._load_cached_schedule(group_code, base_date)
        if cached is not None:
            return cached
        url = self.get_url_for_group(group_code)
        if not url:
            return {}
        schedule = await asyncio.to_thread(parse_schedule, url)
        if schedule:
            self._save_schedule(group_code, base_date, schedule)
        return schedule

    async def get_day_schedule_text(self, group_code: str, date_obj: dt.date) -> str:
        schedule = await self._fetch_schedule_for_group(group_code, date_obj)
        if not schedule:
            return f"–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –≥—Ä—É–ø–ø—ã <b>{group_code}</b>."
        date_str = date_obj.strftime("%d.%m.%Y")
        info = schedule.get(date_str, {})
        header, lessons = normalize_day(date_str, info)
        header_text = f"<b>{header}</b>\n"
        lessons_text = "\n".join(lessons)
        return header_text + f"<blockquote>{lessons_text}</blockquote>"

    async def get_week_schedule_text(self, group_code: str, base_date: dt.date) -> str:
        schedule = await self._fetch_schedule_for_group(group_code, base_date)
        if not schedule:
            return f"–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –≥—Ä—É–ø–ø—ã <b>{group_code}</b>."
        monday, saturday = week_mon_sat_for_display(base_date)
        parts = []
        current = monday
        while current <= saturday:
            date_str = current.strftime("%d.%m.%Y")
            info = schedule.get(date_str, {})
            header, lessons = normalize_day(date_str, info)
            lessons_text = "\n".join(lessons)
            block_text = f"<b>{header}</b>\n<blockquote>{lessons_text}</blockquote>"
            parts.append(block_text)
            current += dt.timedelta(days=1)
        if not parts:
            return f"–î–ª—è –Ω–µ–¥–µ–ª–∏, –Ω–∞—á–∏–Ω–∞—é—â–µ–π—Å—è {monday.strftime('%d.%m.%Y')}, —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ."
        return "\n\n".join(parts)

    async def get_unique_subjects_for_week(self, group_code: str, base_date: dt.date) -> list[str]:
        schedule = await self._fetch_schedule_for_group(group_code, base_date)
        subjects = set()
        for info in schedule.values():
            pairs_dict = info.get("pairs", {})
            merge_dict = info.get("merge", {})
            for p_list in pairs_dict.values():
                for raw in p_list:
                    if raw:
                        parts = raw.split("|")
                        if parts:
                            subj = parts[0].strip()
                            if subj:
                                subjects.add(subj)
            for raw in merge_dict.values():
                if raw:
                    parts = raw.split("|")
                    if parts:
                        subj = parts[0].strip()
                        if subj:
                            subjects.add(subj)
        return sorted(list(subjects))

24. app/services/schedule_watchdog.py  (9.6KB, 2025-11-25 19:25:26)
   –†–æ–ª—å: Schedule/Calendar
   –ò–º–ø–æ—Ä—Ç—ã (–ª–æ–∫–∞–ª—å–Ω—ã–µ): app.core.context, app.services.schedule_service
   –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ—Ç—Å—è –º–æ–¥—É–ª—è–º–∏: app.core.bot
–ö–æ–¥:
import asyncio
import datetime as dt
import json
import logging
import re
from pathlib import Path
from typing import Any

from aiogram import Bot

from app.core.context import get_context
from app.services.schedule_service import week_bounds_mon_sun, parse_schedule, normalize_day, day_name_ru

_HEADER_RE = re.compile(r"^\s*(\d+)\s*–ø–∞—Ä–∞\s*:\s*(.*)$", re.IGNORECASE)
_BULLET_RE = re.compile(r"^\s*[‚ë†‚ë°‚Ä¢\-]\s*")
_NO_RE = re.compile(r"^(–Ω–µ—Ç|–Ω–µ—Ç –ø–∞—Ä|‚Äî|-)$", re.IGNORECASE)

BASE_DIR = Path(__file__).resolve().parents[2]
TMP_DIR = BASE_DIR / "config"
TMP_DIR.mkdir(parents=True, exist_ok=True)
STATE_PATH = TMP_DIR / "watchdog_state.json"
SCHEDULE_CACHE_DIR = TMP_DIR / "watchdog_schedule"
OVERLAY_PATH = TMP_DIR / "schedule_overlay.json"
SCHEDULE_CACHE_DIR.mkdir(parents=True, exist_ok=True)


def _clean(s: str | None) -> str:
    return re.sub(r"\s+", " ", (s or "").replace("\xa0", " ")).strip()


def _normalize_day_lines(dstr: str, info: Any) -> list[str]:
    _, lines = normalize_day(dstr, info, max_pairs=8, subgroup=None, multiline=False)
    return lines or []


def _parse_slots(lines: list[str] | None) -> dict[int, list[str]]:
    slots: dict[int, list[str]] = {}
    j = 0
    n = len(lines or [])
    while j < n:
        raw = lines[j] if lines[j] is not None else ""
        line = _clean(str(raw))
        m = _HEADER_RE.match(line)
        if not m:
            j += 1
            continue
        num = int(m.group(1))
        tail = _clean(m.group(2))
        items: list[str] = []
        if tail and not _NO_RE.fullmatch(tail):
            items.append(_BULLET_RE.sub("", tail))
        k = j + 1
        while k < n:
            raw_next = lines[k] if lines[k] is not None else ""
            nxt = _clean(str(raw_next))
            if _HEADER_RE.match(nxt):
                break
            if nxt and not _NO_RE.fullmatch(nxt):
                items.append(_BULLET_RE.sub("", nxt))
            k += 1
        slots[num] = [x for x in items if x]
        j = k
    return slots


def _norm_join(arr: list[str] | None) -> str:
    return _clean(" | ".join([_clean(x) for x in (arr or []) if _clean(x)]))


def _build_changes(
    old_slots: dict[int, list[str]],
    new_slots: dict[int, list[str]],
) -> tuple[list[tuple[int, str]], list[tuple[int, str]], list[tuple[int, str, str]]]:
    all_keys = set(old_slots.keys()) | set(new_slots.keys())
    removed: list[tuple[int, str]] = []
    added: list[tuple[int, str]] = []
    changed: list[tuple[int, str, str]] = []
    for k in sorted(all_keys):
        o = old_slots.get(k) or []
        n = new_slots.get(k) or []
        o_s = _norm_join(o)
        n_s = _norm_join(n)
        if not o_s and not n_s:
            continue
        if o_s and not n_s:
            removed.append((k, o_s))
        elif not o_s and n_s:
            added.append((k, n_s))
        elif o_s != n_s:
            changed.append((k, o_s, n_s))
    return removed, added, changed


def _format_message(
    group: str,
    now_dt: dt.datetime,
    ddate: dt.date,
    dstr: str,
    removed: list[tuple[int, str]],
    added: list[tuple[int, str]],
    changed: list[tuple[int, str, str]],
) -> str:
    head: list[str] = []
    head.append("–ì—Ä—É–ø–ø–∞: " + str(group))
    head.append("")
    head.append("üóìÔ∏è –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è")
    head.append("‚è∞ " + now_dt.strftime("%d.%m.%Y %H:%M"))
    head.append("")
    head.append(day_name_ru(ddate.weekday()) + " ‚Ä¢ " + dstr)
    body: list[str] = []
    for k, o in removed:
        body.append(f"‚Ä¢ {k} –ø–∞—Ä–∞: –æ—Ç–º–µ–Ω–µ–Ω–∞ ¬´{o}¬ª")
    for k, n in added:
        body.append(f"‚Ä¢ {k} –ø–∞—Ä–∞: –¥–æ–±–∞–≤–ª–µ–Ω–∞ ¬´{n}¬ª")
    for k, o, n in changed:
        body.append(f"‚Ä¢ {k} –ø–∞—Ä–∞: –∏–∑–º–µ–Ω–µ–Ω–∞ ¬´{o}¬ª ‚Üí ¬´{n}¬ª")
    if not body:
        body.append("‚Ä¢ –ò–∑–º–µ–Ω–µ–Ω–∏–π –Ω–µ—Ç")
    return "\n".join(head + body)


def _load_state() -> dict[str, str]:
    if not STATE_PATH.exists():
        return {}
    try:
        with STATE_PATH.open("r", encoding="utf-8") as f:
            data = json.load(f)
        if isinstance(data, dict):
            out: dict[str, str] = {}
            for k, v in data.items():
                if isinstance(k, str) and isinstance(v, str):
                    out[k] = v
            return out
        return {}
    except Exception:
        return {}


def _save_state(state: dict[str, str]) -> None:
    try:
        with STATE_PATH.open("w", encoding="utf-8") as f:
            json.dump(state, f, ensure_ascii=False)
    except Exception:
        pass


def _safe_parse(url: str) -> dict[str, Any]:
    try:
        data = parse_schedule(url)
        if isinstance(data, dict):
            return data
        return {}
    except Exception as e:
        logging.error("watchdog: parse failed: %s", e)
        return {}


def _should_skip_false_cancel(old_slots: dict[int, list[str]], new_slots: dict[int, list[str]]) -> bool:
    o_cnt = sum(1 for v in old_slots.values() if _norm_join(v))
    n_cnt = sum(1 for v in new_slots.values() if _norm_join(v))
    return o_cnt > 0 and n_cnt == 0


def _week_path(group: str, monday: dt.date, sunday: dt.date) -> Path:
    return SCHEDULE_CACHE_DIR / f"{group}_{monday.strftime('%Y%m%d')}_{sunday.strftime('%Y%m%d')}.json"


def _load_week(group: str, monday: dt.date, sunday: dt.date) -> dict[str, Any]:
    path = _week_path(group, monday, sunday)
    if not path.exists():
        return {}
    try:
        with path.open("r", encoding="utf-8") as f:
            data = json.load(f)
        if isinstance(data, dict):
            return data
        return {}
    except Exception:
        return {}


def _save_week(group: str, monday: dt.date, sunday: dt.date, data: dict[str, Any]) -> None:
    path = _week_path(group, monday, sunday)
    try:
        path.parent.mkdir(parents=True, exist_ok=True)
        with path.open("w", encoding="utf-8") as f:
            json.dump(data, f, ensure_ascii=False)
    except Exception:
        pass


def _load_overlay() -> dict[str, Any]:
    if not OVERLAY_PATH.exists():
        return {}
    try:
        with OVERLAY_PATH.open("r", encoding="utf-8") as f:
            data = json.load(f)
        if isinstance(data, dict):
            return data
        return {}
    except Exception:
        return {}


async def schedule_watchdog_loop(bot: Bot, tz: dt.tzinfo) -> None:
    state = _load_state()
    while True:
        try:
            ctx = get_context()
        except Exception:
            await asyncio.sleep(2)
            continue
        try:
            schedule_service = ctx.schedule_service
            url_map = getattr(schedule_service, "url_map", {}) or {}
            overlay_all = _load_overlay()
            now = dt.datetime.now(tz)
            targets = [now.date(), now.date() + dt.timedelta(days=1)]
            for g, url in list(url_map.items()):
                if not url:
                    continue
                for tgt in targets:
                    cmonday, csunday = week_bounds_mon_sun(tgt)
                    old_week = _load_week(g, cmonday, csunday) or {}
                    fresh = await asyncio.to_thread(_safe_parse, url)
                    overlay = overlay_all.get(g, {}) or {}
                    for dstr, info in list(overlay.items()):
                        try:
                            d = dt.datetime.strptime(dstr, "%d.%m.%Y").date()
                        except Exception:
                            continue
                        if cmonday <= d <= csunday:
                            fresh[dstr] = info
                    dstr = tgt.strftime("%d.%m.%Y")
                    new_info = fresh.get(dstr)
                    if new_info is None:
                        continue
                    old_info = old_week.get(dstr, {"day": "", "lessons": []})
                    old_lines = _normalize_day_lines(dstr, old_info)
                    new_lines = _normalize_day_lines(dstr, new_info)
                    old_slots = _parse_slots(old_lines)
                    new_slots = _parse_slots(new_lines)
                    removed, added, changed = _build_changes(old_slots, new_slots)
                    if not removed and not added and not changed:
                        continue
                    if _should_skip_false_cancel(old_slots, new_slots):
                        continue
                    fingerprint = json.dumps(
                        {"rem": removed, "add": added, "chg": changed},
                        ensure_ascii=False,
                    )
                    key = f"{g}:{dstr}"
                    if state.get(key) == fingerprint:
                        continue
                    msg = _format_message(g, now, tgt, dstr, removed, added, changed)
                    users = await ctx.db.get_users_for_schedule_notifications(g)
                    for u in users:
                        tg_id = u.get("tg_id")
                        if not tg_id:
                            continue
                        username = u.get("username")
                        banned = await ctx.db.is_user_banned(tg_id, username)
                        if banned:
                            continue
                        try:
                            await bot.send_message(tg_id, msg, disable_web_page_preview=True)
                        except TypeError:
                            await bot.send_message(tg_id, msg)
                        except Exception:
                            await ctx.db.set_user_blocked(tg_id, True)
                    _save_week(g, cmonday, csunday, fresh)
                    state[key] = fingerprint
                    _save_state(state)
        except Exception as e:
            logging.error("watchdog loop: %s", e)
        await asyncio.sleep(30)

25. config/homeworks/ai_logs.jsonl  (1.9KB, 2025-11-26 23:03:25)
   –†–æ–ª—å: Asset
–ö–æ–¥:
{"timestamp": "2025-11-26T18:03:25.196155", "user_id": 1843578375, "username": "mihort", "full_name": "Mihort", "subject": "–ë–∞—à–∫–∏—Ä—Å–∫–∏–π —è–∑—ã–∫ (–õ–µ–∫.)", "text": "–í—Ä–æ–¥–µ –Ω–µ—Ç—Ü", "telegraph_url": null, "ai_result": {"decision": "–Ω–µ—Ç", "reason": "–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞–∑–æ–±—Ä–∞—Ç—å –æ—Ç–≤–µ—Ç –º–æ–¥–µ–ª–∏", "raw": "{\"choices\":[{\"content_filter_results\":{\"hate\":{\"filtered\":false,\"severity\":\"safe\"},\"protected_material_text\":{\"filtered\":false,\"detected\":false},\"self_harm\":{\"filtered\":false,\"severity\":\"safe\"},\"sexual\":{\"filtered\":false,\"severity\":\"safe\"},\"violence\":{\"filtered\":false,\"severity\":\"safe\"}},\"finish_reason\":\"stop\",\"index\":0,\"logprobs\":null,\"message\":{\"annotations\":[],\"content\":\"–Ω–µ—Ç. –¢–µ–∫—Å—Ç —Å–ª–∏—à–∫–æ–º –∫–æ—Ä–æ—Ç–∫–∏–π –∏ –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç —ç–ª–µ–º–µ–Ω—Ç–æ–≤, —Ö–∞—Ä–∞–∫—Ç–µ—Ä–Ω—ã—Ö –¥–ª—è —à–∫–æ–ª—å–Ω–æ–≥–æ –¥–æ–º–∞—à–Ω–µ–≥–æ –∑–∞–¥–∞–Ω–∏—è (—Ü–µ–ª–∏, –∑–∞–¥–∞—á–∏, –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏, —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è –∫ –æ–±—ä–µ–º—É/—Ñ–æ—Ä–º–∞—Ç—É).\",\"refusal\":null,\"role\":\"assistant\"}}],\"created\":1764180196,\"id\":\"pllns_8355b2f2231452c2c54ebfce763a5e74\",\"model\":\"gpt-5-nano-2025-08-07\",\"object\":\"chat.completion\",\"prompt_filter_results\":[{\"prompt_index\":0,\"content_filter_results\":{\"hate\":{\"filtered\":false,\"severity\":\"safe\"},\"jailbreak\":{\"filtered\":false,\"detected\":false},\"self_harm\":{\"filtered\":false,\"severity\":\"safe\"},\"sexual\":{\"filtered\":false,\"severity\":\"safe\"},\"violence\":{\"filtered\":false,\"severity\":\"safe\"}}}],\"system_fingerprint\":null,\"usage\":{\"completion_tokens\":623,\"completion_tokens_details\":{\"accepted_prediction_tokens\":0,\"audio_tokens\":0,\"reasoning_tokens\":576,\"rejected_prediction_tokens\":0},\"prompt_tokens\":65,\"prompt_tokens_details\":{\"audio_tokens\":0,\"cached_tokens\":0},\"total_tokens\":688},\"user_tier\":\"anonymous\"}"}}

26. main.py  (617B, 2025-11-22 00:03:07)
   –†–æ–ª—å: Entry point
   –ò–º–ø–æ—Ä—Ç—ã (–ª–æ–∫–∞–ª—å–Ω—ã–µ): app.core.bot, app.core.config, app.core.fsm_storage
–ö–æ–¥:
import asyncio

from aiogram import Bot, Dispatcher
from aiogram.client.bot import DefaultBotProperties

from app.core.config import load_config
from app.core.bot import setup_bot
from app.core.fsm_storage import SQLiteStorage


async def main():
    config = load_config()
    bot = Bot(
        token=config.bot_token,
        default=DefaultBotProperties(parse_mode="HTML"),
    )
    storage = SQLiteStorage(str(config.db_path))
    await storage.init()
    dp = Dispatcher(storage=storage)
    await setup_bot(bot, dp, config)
    await dp.start_polling(bot)


if __name__ == "__main__":
    asyncio.run(main())

